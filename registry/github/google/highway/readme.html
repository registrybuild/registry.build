<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">Efficient and performance-portable vector software</h1><a id="user-content-efficient-and-performance-portable-vector-software" class="anchor" aria-label="Permalink: Efficient and performance-portable vector software" href="#efficient-and-performance-portable-vector-software"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Highway is a C++ library that provides portable SIMD/vector intrinsics.</p>
<p dir="auto"><a href="https://google.github.io/highway/en/master/" rel="nofollow">Documentation</a></p>
<p dir="auto">Previously licensed under Apache 2, now dual-licensed as Apache 2 / BSD-3.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Why</h2><a id="user-content-why" class="anchor" aria-label="Permalink: Why" href="#why"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">We are passionate about high-performance software. We see major untapped
potential in CPUs (servers, mobile, desktops). Highway is for engineers who want
to reliably and economically push the boundaries of what is possible in
software.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">How</h2><a id="user-content-how" class="anchor" aria-label="Permalink: How" href="#how"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">CPUs provide SIMD/vector instructions that apply the same operation to multiple
data items. This can reduce energy usage e.g. <em>fivefold</em> because fewer
instructions are executed. We also often see <em>5-10x</em> speedups.</p>
<p dir="auto">Highway makes SIMD/vector programming practical and workable according to these
guiding principles:</p>
<p dir="auto"><strong>Does what you expect</strong>: Highway is a C++ library with carefully-chosen
functions that map well to CPU instructions without extensive compiler
transformations. The resulting code is more predictable and robust to code
changes/compiler updates than autovectorization.</p>
<p dir="auto"><strong>Works on widely-used platforms</strong>: Highway supports five architectures; the
same application code can target various instruction sets, including those with
'scalable' vectors (size unknown at compile time). Highway only requires C++11
and supports four families of compilers. If you would like to use Highway on
other platforms, please raise an issue.</p>
<p dir="auto"><strong>Flexible to deploy</strong>: Applications using Highway can run on heterogeneous
clouds or client devices, choosing the best available instruction set at
runtime. Alternatively, developers may choose to target a single instruction set
without any runtime overhead. In both cases, the application code is the same
except for swapping <code>HWY_STATIC_DISPATCH</code> with <code>HWY_DYNAMIC_DISPATCH</code> plus one
line of code. See also @kfjahnke's
<a href="https://github.com/kfjahnke/zimt/blob/multi_isa/examples/multi_isa_example/multi_simd_isa.md">introduction to dispatching</a>.</p>
<p dir="auto"><strong>Suitable for a variety of domains</strong>: Highway provides an extensive set of
operations, used for image processing (floating-point), compression, video
analysis, linear algebra, cryptography, sorting and random generation. We
recognise that new use-cases may require additional ops and are happy to add
them where it makes sense (e.g. no performance cliffs on some architectures). If
you would like to discuss, please file an issue.</p>
<p dir="auto"><strong>Rewards data-parallel design</strong>: Highway provides tools such as Gather,
MaskedLoad, and FixedTag to enable speedups for legacy data structures. However,
the biggest gains are unlocked by designing algorithms and data structures for
scalable vectors. Helpful techniques include batching, structure-of-array
layouts, and aligned/padded allocations.</p>
<p dir="auto">We recommend these resources for getting started:</p>
<ul dir="auto">
<li><a href="http://const.me/articles/simd/simd.pdf" rel="nofollow">SIMD for C++ Developers</a></li>
<li><a href="https://en.algorithmica.org/hpc/" rel="nofollow">Algorithms for Modern Hardware</a></li>
<li><a href="https://agner.org/optimize/optimizing_cpp.pdf" rel="nofollow">Optimizing software in C++</a></li>
<li><a href="https://stackoverflow.blog/2020/07/08/improving-performance-with-simd-intrinsics-in-three-use-cases/" rel="nofollow">Improving performance with SIMD intrinsics in three use cases</a></li>
</ul>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Examples</h2><a id="user-content-examples" class="anchor" aria-label="Permalink: Examples" href="#examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Online demos using Compiler Explorer:</p>
<ul dir="auto">
<li><a href="https://gcc.godbolt.org/z/KM3ben7ET" rel="nofollow">multiple targets with dynamic dispatch</a>
(more complicated, but flexible and uses best available SIMD)</li>
<li><a href="https://gcc.godbolt.org/z/rGnjMevKG" rel="nofollow">single target using -m flags</a>
(simpler, but requires/only uses the instruction set enabled by compiler
flags)</li>
</ul>
<p dir="auto">We observe that Highway is referenced in the following open source projects,
found via sourcegraph.com. Most are GitHub repositories. If you would like to
add your project or link to it directly, feel free to raise an issue or contact
us via the below email.</p>
<ul dir="auto">
<li>Audio: <a href="https://github.com/google/zimtohrli">Zimtohrli perceptual metric</a></li>
<li>Browsers: Chromium (+Vivaldi), Firefox (+floorp / foxhound / librewolf /
Waterfox)</li>
<li>Computational biology: <a href="https://github.com/bnprks/BPCells">RNA analysis</a></li>
<li>Computer graphics: <a href="https://github.com/rools/voxl">Sparse voxel renderer</a></li>
<li>Cryptography: google/distributed_point_functions, google/shell-encryption</li>
<li>Data structures: bkille/BitLib</li>
<li>Image codecs: eustas/2im,
<a href="https://github.com/GrokImageCompression/grok">Grok JPEG 2000</a>,
<a href="https://github.com/libjxl/libjxl">JPEG XL</a>,
<a href="https://github.com/osamu620/JPEGenc">JPEGenc</a>,
<a href="https://github.com/google/jpegli">Jpegli</a>, OpenHTJ2K</li>
<li>Image processing: cloudinary/ssimulacra2, m-ab-s/media-autobuild_suite,
<a href="https://github.com/libvips/libvips">libvips</a></li>
<li>Image viewers: AlienCowEatCake/ImageViewer, diffractor/diffractor,
mirillis/jpegxl-wic,
<a href="https://bitbucket.org/kfj/pv/" rel="nofollow">Lux panorama/image viewer</a></li>
<li>Information retrieval:
<a href="https://github.com/iresearch-toolkit/iresearch">iresearch database index</a>,
michaeljclark/zvec,
<a href="https://github.com/varchar-io/nebula">nebula interactive analytics / OLAP</a>,
<a href="https://github.com/google-research/google-research/tree/7a269cb2ce0ae1db591fe11b62cbc0be7d72532a/scann">ScaNN Scalable Nearest Neighbors</a>,
<a href="https://github.com/1yefuwang1/vectorlite/">vectorlite vector search</a></li>
<li>Machine learning: <a href="https://github.com/google/gemma.cpp">gemma.cpp</a>,
Tensorflow, Numpy, zpye/SimpleInfer</li>
<li>Robotics:
<a href="https://github.com/RobotLocomotion/drake">MIT Model-Based Design and Verification</a></li>
</ul>
<p dir="auto">Other</p>
<ul dir="auto">
<li><a href="https://www.mnm-team.org/pub/Fopras/rock23/" rel="nofollow">Evaluation of C++ SIMD Libraries</a>:
"Highway excelled with a strong performance across multiple SIMD extensions
[..]. Thus, Highway may currently be the most suitable SIMD library for many
software projects."</li>
<li><a href="https://github.com/kfjahnke/zimt">zimt</a>: C++11 template library to process n-dimensional arrays with multi-threaded SIMD code</li>
<li><a href="https://github.com/google/highway/tree/master/hwy/contrib/sort">vectorized Quicksort</a> (<a href="https://arxiv.org/abs/2205.05982" rel="nofollow">paper</a>)</li>
</ul>
<p dir="auto">If you'd like to get Highway, in addition to cloning from this GitHub repository
or using it as a Git submodule, you can also find it in the following package
managers or repositories:</p>
<ul dir="auto">
<li>alpinelinux</li>
<li>conan-io</li>
<li>conda-forge</li>
<li>DragonFlyBSD,</li>
<li>fd00/yacp</li>
<li>freebsd</li>
<li>getsolus/packages</li>
<li>ghostbsd</li>
<li>microsoft/vcpkg</li>
<li>MidnightBSD</li>
<li>MSYS2</li>
<li>NetBSD</li>
<li>openSUSE</li>
<li>opnsense</li>
<li>Xilinx/Vitis_Libraries</li>
<li>xmake-io/xmake-repo</li>
</ul>
<p dir="auto">See also the list at <a href="https://repology.org/project/highway-simd-library/versions" rel="nofollow">https://repology.org/project/highway-simd-library/versions</a>
.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Current status</h2><a id="user-content-current-status" class="anchor" aria-label="Permalink: Current status" href="#current-status"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">Targets</h3><a id="user-content-targets" class="anchor" aria-label="Permalink: Targets" href="#targets"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Highway supports 24 targets, listed in alphabetical order of platform:</p>
<ul dir="auto">
<li>Any: <code>EMU128</code>, <code>SCALAR</code>;</li>
<li>Armv7+: <code>NEON_WITHOUT_AES</code>, <code>NEON</code>, <code>NEON_BF16</code>, <code>SVE</code>, <code>SVE2</code>, <code>SVE_256</code>,
<code>SVE2_128</code>;</li>
<li>IBM Z: <code>Z14</code>, <code>Z15</code>;</li>
<li>POWER: <code>PPC8</code> (v2.07), <code>PPC9</code> (v3.0), <code>PPC10</code> (v3.1B, not yet supported due
to compiler bugs, see #1207; also requires QEMU 7.2);</li>
<li>RISC-V: <code>RVV</code> (1.0);</li>
<li>WebAssembly: <code>WASM</code>, <code>WASM_EMU256</code> (a 2x unrolled version of wasm128,
enabled if <code>HWY_WANT_WASM2</code> is defined. This will remain supported until it
is potentially superseded by a future version of WASM.);</li>
<li>x86:
<ul dir="auto">
<li><code>SSE2</code></li>
<li><code>SSSE3</code> (~Intel Core)</li>
<li><code>SSE4</code> (~Nehalem, also includes AES + CLMUL).</li>
<li><code>AVX2</code> (~Haswell, also includes BMI2 + F16 + FMA)</li>
<li><code>AVX3</code> (~Skylake, AVX-512F/BW/CD/DQ/VL)</li>
<li><code>AVX3_DL</code> (~Icelake, includes BitAlg + CLMUL + GFNI + VAES + VBMI +
VBMI2 + VNNI + VPOPCNT; requires opt-in by defining <code>HWY_WANT_AVX3_DL</code>
unless compiling for static dispatch),</li>
<li><code>AVX3_ZEN4</code> (like AVX3_DL but optimized for AMD Zen4; requires opt-in by
defining <code>HWY_WANT_AVX3_ZEN4</code> if compiling for static dispatch, but
enabled by default for runtime dispatch),</li>
<li><code>AVX3_SPR</code> (~Sapphire Rapids, includes AVX-512FP16)</li>
</ul>
</li>
</ul>
<p dir="auto">Our policy is that unless otherwise specified, targets will remain supported as
long as they can be (cross-)compiled with currently supported Clang or GCC, and
tested using QEMU. If the target can be compiled with LLVM trunk and tested
using our version of QEMU without extra flags, then it is eligible for inclusion
in our continuous testing infrastructure. Otherwise, the target will be manually
tested before releases with selected versions/configurations of Clang and GCC.</p>
<p dir="auto">SVE was initially tested using farm_sve (see acknowledgments).</p>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">Versioning</h3><a id="user-content-versioning" class="anchor" aria-label="Permalink: Versioning" href="#versioning"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Highway releases aim to follow the semver.org system (MAJOR.MINOR.PATCH),
incrementing MINOR after backward-compatible additions and PATCH after
backward-compatible fixes. We recommend using releases (rather than the Git tip)
because they are tested more extensively, see below.</p>
<p dir="auto">The current version 1.0 signals an increased focus on backwards compatibility.
Applications using documented functionality will remain compatible with future
updates that have the same major version number.</p>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">Testing</h3><a id="user-content-testing" class="anchor" aria-label="Permalink: Testing" href="#testing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Continuous integration tests build with a recent version of Clang (running on
native x86, or QEMU for RISC-V and Arm) and MSVC 2019 (v19.28, running on native
x86).</p>
<p dir="auto">Before releases, we also test on x86 with Clang and GCC, and Armv7/8 via GCC
cross-compile. See the <a href="g3doc/release_testing_process.md">testing process</a> for
details.</p>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">Related modules</h3><a id="user-content-related-modules" class="anchor" aria-label="Permalink: Related modules" href="#related-modules"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The <code>contrib</code> directory contains SIMD-related utilities: an image class with
aligned rows, a math library (16 functions already implemented, mostly
trigonometry), and functions for computing dot products and sorting.</p>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">Other libraries</h3><a id="user-content-other-libraries" class="anchor" aria-label="Permalink: Other libraries" href="#other-libraries"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">If you only require x86 support, you may also use Agner Fog's
<a href="https://github.com/vectorclass">VCL vector class library</a>. It includes many
functions including a complete math library.</p>
<p dir="auto">If you have existing code using x86/NEON intrinsics, you may be interested in
<a href="https://github.com/simd-everywhere/simde">SIMDe</a>, which emulates those
intrinsics using other platforms' intrinsics or autovectorization.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Installation</h2><a id="user-content-installation" class="anchor" aria-label="Permalink: Installation" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This project uses CMake to generate and build. In a Debian-based system you can
install it via:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="sudo apt install cmake"><pre>sudo apt install cmake</pre></div>
<p dir="auto">Highway's unit tests use <a href="https://github.com/google/googletest">googletest</a>.
By default, Highway's CMake downloads this dependency at configuration time.
You can avoid this by setting the <code>HWY_SYSTEM_GTEST</code> CMake variable to ON and
installing gtest separately:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="sudo apt install libgtest-dev"><pre>sudo apt install libgtest-dev</pre></div>
<p dir="auto">Alternatively, you can define <code>HWY_TEST_STANDALONE=1</code> and remove all occurrences
of <code>gtest_main</code> in each BUILD file, then tests avoid the dependency on GUnit.</p>
<p dir="auto">Running cross-compiled tests requires support from the OS, which on Debian is
provided by the <code>qemu-user-binfmt</code> package.</p>
<p dir="auto">To build Highway as a shared or static library (depending on BUILD_SHARED_LIBS),
the standard CMake workflow can be used:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mkdir -p build &amp;&amp; cd build
cmake ..
make -j &amp;&amp; make test"><pre>mkdir -p build <span class="pl-k">&amp;&amp;</span> <span class="pl-c1">cd</span> build
cmake ..
make -j <span class="pl-k">&amp;&amp;</span> make <span class="pl-c1">test</span></pre></div>
<p dir="auto">Or you can run <code>run_tests.sh</code> (<code>run_tests.bat</code> on Windows).</p>
<p dir="auto">Bazel is also supported for building, but it is not as widely used/tested.</p>
<p dir="auto">When building for Armv7, a limitation of current compilers requires you to add
<code>-DHWY_CMAKE_ARM7:BOOL=ON</code> to the CMake command line; see #834 and #1032. We
understand that work is underway to remove this limitation.</p>
<p dir="auto">Building on 32-bit x86 is not officially supported, and AVX2/3 are disabled by
default there. Note that johnplatts has successfully built and run the Highway
tests on 32-bit x86, including AVX2/3, on GCC 7/8 and Clang 8/11/12. On Ubuntu
22.04, Clang 11 and 12, but not later versions, require extra compiler flags
<code>-m32 -isystem /usr/i686-linux-gnu/include</code>. Clang 10 and earlier require the
above plus <code>-isystem /usr/i686-linux-gnu/include/c++/12/i686-linux-gnu</code>. See
#1279.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Building highway - Using vcpkg</h2><a id="user-content-building-highway---using-vcpkg" class="anchor" aria-label="Permalink: Building highway - Using vcpkg" href="#building-highway---using-vcpkg"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">highway is now available in <a href="https://github.com/Microsoft/vcpkg">vcpkg</a></p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="vcpkg install highway"><pre>vcpkg install highway</pre></div>
<p dir="auto">The highway port in vcpkg is kept up to date by Microsoft team members and community contributors. If the version is out of date, please <a href="https://github.com/Microsoft/vcpkg">create an issue or pull request</a> on the vcpkg repository.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Quick start</h2><a id="user-content-quick-start" class="anchor" aria-label="Permalink: Quick start" href="#quick-start"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">You can use the <code>benchmark</code> inside examples/ as a starting point.</p>
<p dir="auto">A <a href="g3doc/quick_reference.md">quick-reference page</a> briefly lists all operations
and their parameters, and the <a href="g3doc/instruction_matrix.pdf">instruction_matrix</a>
indicates the number of instructions per operation.</p>
<p dir="auto">The <a href="g3doc/faq.md">FAQ</a> answers questions about portability, API design and
where to find more information.</p>
<p dir="auto">We recommend using full SIMD vectors whenever possible for maximum performance
portability. To obtain them, pass a <code>ScalableTag&lt;float&gt;</code> (or equivalently
<code>HWY_FULL(float)</code>) tag to functions such as <code>Zero/Set/Load</code>. There are two
alternatives for use-cases requiring an upper bound on the lanes:</p>
<ul dir="auto">
<li>
<p dir="auto">For up to <code>N</code> lanes, specify <code>CappedTag&lt;T, N&gt;</code> or the equivalent
<code>HWY_CAPPED(T, N)</code>. The actual number of lanes will be <code>N</code> rounded down to
the nearest power of two, such as 4 if <code>N</code> is 5, or 8 if <code>N</code> is 8. This is
useful for data structures such as a narrow matrix. A loop is still required
because vectors may actually have fewer than <code>N</code> lanes.</p>
</li>
<li>
<p dir="auto">For exactly a power of two <code>N</code> lanes, specify <code>FixedTag&lt;T, N&gt;</code>. The largest
supported <code>N</code> depends on the target, but is guaranteed to be at least
<code>16/sizeof(T)</code>.</p>
</li>
</ul>
<p dir="auto">Due to ADL restrictions, user code calling Highway ops must either:</p>
<ul dir="auto">
<li>Reside inside <code>namespace hwy { namespace HWY_NAMESPACE {</code>; or</li>
<li>prefix each op with an alias such as <code>namespace hn = hwy::HWY_NAMESPACE; hn::Add()</code>; or</li>
<li>add using-declarations for each op used: <code>using hwy::HWY_NAMESPACE::Add;</code>.</li>
</ul>
<p dir="auto">Additionally, each function that calls Highway ops (such as <code>Load</code>) must either
be prefixed with <code>HWY_ATTR</code>, OR reside between <code>HWY_BEFORE_NAMESPACE()</code> and
<code>HWY_AFTER_NAMESPACE()</code>. Lambda functions currently require <code>HWY_ATTR</code> before
their opening brace.</p>
<p dir="auto">Do not use namespace-scope nor <code>static</code> initializers for SIMD vectors because
this can cause SIGILL when using runtime dispatch and the compiler chooses an
initializer compiled for a target not supported by the current CPU. Instead,
constants initialized via <code>Set</code> should generally be local (const) variables.</p>
<p dir="auto">The entry points into code using Highway differ slightly depending on whether
they use static or dynamic dispatch. In both cases, we recommend that the
top-level function receives one or more pointers to arrays, rather than
target-specific vector types.</p>
<ul dir="auto">
<li>
<p dir="auto">For static dispatch, <code>HWY_TARGET</code> will be the best available target among
<code>HWY_BASELINE_TARGETS</code>, i.e. those allowed for use by the compiler (see
<a href="g3doc/quick_reference.md">quick-reference</a>). Functions inside
<code>HWY_NAMESPACE</code> can be called using <code>HWY_STATIC_DISPATCH(func)(args)</code> within
the same module they are defined in. You can call the function from other
modules by wrapping it in a regular function and declaring the regular
function in a header.</p>
</li>
<li>
<p dir="auto">For dynamic dispatch, a table of function pointers is generated via the
<code>HWY_EXPORT</code> macro that is used by <code>HWY_DYNAMIC_DISPATCH(func)(args)</code> to
call the best function pointer for the current CPU's supported targets. A
module is automatically compiled for each target in <code>HWY_TARGETS</code> (see
<a href="g3doc/quick_reference.md">quick-reference</a>) if <code>HWY_TARGET_INCLUDE</code> is
defined and <code>foreach_target.h</code> is included. Note that the first invocation
of <code>HWY_DYNAMIC_DISPATCH</code>, or each call to the pointer returned by the first
invocation of <code>HWY_DYNAMIC_POINTER</code>, involves some CPU detection overhead.
You can prevent this by calling the following before any invocation of
<code>HWY_DYNAMIC_*</code>: <code>hwy::GetChosenTarget().Update(hwy::SupportedTargets());</code>.</p>
</li>
</ul>
<p dir="auto">See also a separate
<a href="https://github.com/kfjahnke/zimt/blob/multi_isa/examples/multi_isa_example/multi_simd_isa.md">introduction to dynamic dispatch</a>
by @kfjahnke.</p>
<p dir="auto">When using dynamic dispatch, <code>foreach_target.h</code> is included from translation
units (.cc files), not headers. Headers containing vector code shared between
several translation units require a special include guard, for example the
following taken from <code>examples/skeleton-inl.h</code>:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="#if defined(HIGHWAY_HWY_EXAMPLES_SKELETON_INL_H_) == defined(HWY_TARGET_TOGGLE)
#ifdef HIGHWAY_HWY_EXAMPLES_SKELETON_INL_H_
#undef HIGHWAY_HWY_EXAMPLES_SKELETON_INL_H_
#else
#define HIGHWAY_HWY_EXAMPLES_SKELETON_INL_H_
#endif

#include &quot;hwy/highway.h&quot;
// Your vector code
#endif"><pre class="notranslate"><code>#if defined(HIGHWAY_HWY_EXAMPLES_SKELETON_INL_H_) == defined(HWY_TARGET_TOGGLE)
#ifdef HIGHWAY_HWY_EXAMPLES_SKELETON_INL_H_
#undef HIGHWAY_HWY_EXAMPLES_SKELETON_INL_H_
#else
#define HIGHWAY_HWY_EXAMPLES_SKELETON_INL_H_
#endif

#include "hwy/highway.h"
// Your vector code
#endif
</code></pre></div>
<p dir="auto">By convention, we name such headers <code>-inl.h</code> because their contents (often
function templates) are usually inlined.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Compiler flags</h2><a id="user-content-compiler-flags" class="anchor" aria-label="Permalink: Compiler flags" href="#compiler-flags"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Applications should be compiled with optimizations enabled. Without inlining
SIMD code may slow down by factors of 10 to 100. For clang and GCC, <code>-O2</code> is
generally sufficient.</p>
<p dir="auto">For MSVC, we recommend compiling with <code>/Gv</code> to allow non-inlined functions to
pass vector arguments in registers. If intending to use the AVX2 target together
with half-width vectors (e.g. for <code>PromoteTo</code>), it is also important to compile
with <code>/arch:AVX2</code>. This seems to be the only way to reliably generate
VEX-encoded SSE instructions on MSVC. Sometimes MSVC generates VEX-encoded SSE
instructions, if they are mixed with AVX, but not always, see
<a href="https://developercommunity.visualstudio.com/t/10618264" rel="nofollow">DevCom-10618264</a>.
Otherwise, mixing VEX-encoded AVX2 instructions and non-VEX SSE may cause severe
performance degradation. Unfortunately, with <code>/arch:AVX2</code> option, the resulting
binary will then require AVX2. Note that no such flag is needed for clang and
GCC because they support target-specific attributes, which we use to ensure
proper VEX code generation for AVX2 targets.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Strip-mining loops</h2><a id="user-content-strip-mining-loops" class="anchor" aria-label="Permalink: Strip-mining loops" href="#strip-mining-loops"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">When vectorizing a loop, an important question is whether and how to deal with
a number of iterations ('trip count', denoted <code>count</code>) that does not evenly
divide the vector size <code>N = Lanes(d)</code>. For example, it may be necessary to avoid
writing past the end of an array.</p>
<p dir="auto">In this section, let <code>T</code> denote the element type and <code>d = ScalableTag&lt;T&gt;</code>.
Assume the loop body is given as a function <code>template&lt;bool partial, class D&gt; void LoopBody(D d, size_t index, size_t max_n)</code>.</p>
<p dir="auto">"Strip-mining" is a technique for vectorizing a loop by transforming it into an
outer loop and inner loop, such that the number of iterations in the inner loop
matches the vector width. Then, the inner loop is replaced with vector
operations.</p>
<p dir="auto">Highway offers several strategies for loop vectorization:</p>
<ul dir="auto">
<li>
<p dir="auto">Ensure all inputs/outputs are padded. Then the (outer) loop is simply</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="for (size_t i = 0; i &lt; count; i += N) LoopBody&lt;false&gt;(d, i, 0);"><pre class="notranslate"><code>for (size_t i = 0; i &lt; count; i += N) LoopBody&lt;false&gt;(d, i, 0);
</code></pre></div>
<p dir="auto">Here, the template parameter and second function argument are not needed.</p>
<p dir="auto">This is the preferred option, unless <code>N</code> is in the thousands and vector
operations are pipelined with long latencies. This was the case for
supercomputers in the 90s, but nowadays ALUs are cheap and we see most
implementations split vectors into 1, 2 or 4 parts, so there is little cost
to processing entire vectors even if we do not need all their lanes. Indeed
this avoids the (potentially large) cost of predication or partial
loads/stores on older targets, and does not duplicate code.</p>
</li>
<li>
<p dir="auto">Process whole vectors and include previously processed elements
in the last vector:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="for (size_t i = 0; i &lt; count; i += N) LoopBody&lt;false&gt;(d, HWY_MIN(i, count - N), 0);"><pre class="notranslate"><code>for (size_t i = 0; i &lt; count; i += N) LoopBody&lt;false&gt;(d, HWY_MIN(i, count - N), 0);
</code></pre></div>
<p dir="auto">This is the second preferred option provided that <code>count &gt;= N</code>
and <code>LoopBody</code> is idempotent. Some elements might be processed twice, but
a single code path and full vectorization is usually worth it. Even if
<code>count &lt; N</code>, it usually makes sense to pad inputs/outputs up to <code>N</code>.</p>
</li>
<li>
<p dir="auto">Use the <code>Transform*</code> functions in hwy/contrib/algo/transform-inl.h. This
takes care of the loop and remainder handling and you simply define a
generic lambda function (C++14) or functor which receives the current vector
from the input/output array, plus optionally vectors from up to two extra
input arrays, and returns the value to write to the input/output array.</p>
<p dir="auto">Here is an example implementing the BLAS function SAXPY (<code>alpha * x + y</code>):</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Transform1(d, x, n, y, [](auto d, const auto v, const auto v1) HWY_ATTR {
  return MulAdd(Set(d, alpha), v, v1);
});"><pre class="notranslate"><code>Transform1(d, x, n, y, [](auto d, const auto v, const auto v1) HWY_ATTR {
  return MulAdd(Set(d, alpha), v, v1);
});
</code></pre></div>
</li>
<li>
<p dir="auto">Process whole vectors as above, followed by a scalar loop:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="size_t i = 0;
for (; i + N &lt;= count; i += N) LoopBody&lt;false&gt;(d, i, 0);
for (; i &lt; count; ++i) LoopBody&lt;false&gt;(CappedTag&lt;T, 1&gt;(), i, 0);"><pre class="notranslate"><code>size_t i = 0;
for (; i + N &lt;= count; i += N) LoopBody&lt;false&gt;(d, i, 0);
for (; i &lt; count; ++i) LoopBody&lt;false&gt;(CappedTag&lt;T, 1&gt;(), i, 0);
</code></pre></div>
<p dir="auto">The template parameter and second function arguments are again not needed.</p>
<p dir="auto">This avoids duplicating code, and is reasonable if <code>count</code> is large.
If <code>count</code> is small, the second loop may be slower than the next option.</p>
</li>
<li>
<p dir="auto">Process whole vectors as above, followed by a single call to a modified
<code>LoopBody</code> with masking:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="size_t i = 0;
for (; i + N &lt;= count; i += N) {
  LoopBody&lt;false&gt;(d, i, 0);
}
if (i &lt; count) {
  LoopBody&lt;true&gt;(d, i, count - i);
}"><pre class="notranslate"><code>size_t i = 0;
for (; i + N &lt;= count; i += N) {
  LoopBody&lt;false&gt;(d, i, 0);
}
if (i &lt; count) {
  LoopBody&lt;true&gt;(d, i, count - i);
}
</code></pre></div>
<p dir="auto">Now the template parameter and third function argument can be used inside
<code>LoopBody</code> to non-atomically 'blend' the first <code>num_remaining</code> lanes of <code>v</code>
with the previous contents of memory at subsequent locations:
<code>BlendedStore(v, FirstN(d, num_remaining), d, pointer);</code>. Similarly,
<code>MaskedLoad(FirstN(d, num_remaining), d, pointer)</code> loads the first
<code>num_remaining</code> elements and returns zero in other lanes.</p>
<p dir="auto">This is a good default when it is infeasible to ensure vectors are padded,
but is only safe <code>#if !HWY_MEM_OPS_MIGHT_FAULT</code>!
In contrast to the scalar loop, only a single final iteration is needed.
The increased code size from two loop bodies is expected to be worthwhile
because it avoids the cost of masking in all but the final iteration.</p>
</li>
</ul>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Additional resources</h2><a id="user-content-additional-resources" class="anchor" aria-label="Permalink: Additional resources" href="#additional-resources"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li><a href="g3doc/highway_intro.pdf">Highway introduction (slides)</a></li>
<li><a href="g3doc/instruction_matrix.pdf">Overview of instructions per operation on different architectures</a></li>
<li><a href="g3doc/design_philosophy.md">Design philosophy and comparison</a></li>
<li><a href="g3doc/impl_details.md">Implementation details</a></li>
</ul>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Acknowledgments</h2><a id="user-content-acknowledgments" class="anchor" aria-label="Permalink: Acknowledgments" href="#acknowledgments"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">We have used <a href="https://gitlab.inria.fr/bramas/farm-sve" rel="nofollow">farm-sve</a> by Berenger
Bramas; it has proved useful for checking the SVE port on an x86 development
machine.</p>
<p dir="auto">This is not an officially supported Google product.
Contact: <a href="mailto:janwas@google.com">janwas@google.com</a></p>
</article></div>