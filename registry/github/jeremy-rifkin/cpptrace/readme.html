<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">Cpptrace </h1><a id="user-content-cpptrace-" class="anchor" aria-label="Permalink: Cpptrace " href="#cpptrace-"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://github.com/jeremy-rifkin/cpptrace/actions/workflows/ci.yml"><img src="https://github.com/jeremy-rifkin/cpptrace/actions/workflows/ci.yml/badge.svg?branch=main" alt="CI" style="max-width: 100%;"></a>
<a href="https://sonarcloud.io/summary/new_code?id=jeremy-rifkin_cpptrace" rel="nofollow"><img src="https://camo.githubusercontent.com/748d809e498977e491efcc38141944f7f6b61f79561a8675d10cf677ef89cf11/68747470733a2f2f736f6e6172636c6f75642e696f2f6170692f70726f6a6563745f6261646765732f6d6561737572653f70726f6a6563743d6a6572656d792d7269666b696e5f6370707472616365266d65747269633d616c6572745f737461747573" alt="Quality Gate Status" data-canonical-src="https://sonarcloud.io/api/project_badges/measure?project=jeremy-rifkin_cpptrace&amp;metric=alert_status" style="max-width: 100%;"></a>
<br>
<a href="https://discord.gg/frjaAZvqUZ" rel="nofollow"><img src="https://camo.githubusercontent.com/52a0695ddab8d4a5274bb8d94135a8625796ef13f0e8ee81ed9297d0d27c2908/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f436861742532306f6e2532307468652532302876657279253230736d616c6c292d436f6d6d756e697479253230446973636f72642d626c75653f6c6162656c436f6c6f723d32433332333926636f6c6f723d373238394441267374796c653d666c6174266c6f676f3d646973636f7264266c6f676f436f6c6f723d393539444135" alt="Community Discord Link" data-canonical-src="https://img.shields.io/badge/Chat%20on%20the%20(very%20small)-Community%20Discord-blue?labelColor=2C3239&amp;color=7289DA&amp;style=flat&amp;logo=discord&amp;logoColor=959DA5" style="max-width: 100%;"></a>
<br>
<a href="https://godbolt.org/z/aP8PsxxeY" rel="nofollow"><img src="https://camo.githubusercontent.com/56e5825395999b33ebc2967b2b0a56f24b945fadbff50742e6df3f3c73231e44/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f2d436f6d70696c65722532304578706c6f7265722d627269676874677265656e3f6c6f676f3d646174613a696d6167652f706e673b6261736536342c6956424f5277304b47676f414141414e53556845556741414141344141414151434159414141416d6c453436414141414358424957584d41414143774141414173414555617174704141414253456c455156516f6b595654735537444d424239514d5443454a624f4d4c42356f463074526655504950494a5a6374594a6b5a597533574d784e4c2b41525566514b70496d63506744596e735857426759516c3631546b597978493357656633376a33666e512f36766b6373696b59394162695771306d7062657644426d4c527144454141344345484d4144674652777277446d6368365832693733524346564876432f574365434d414670433241466f5050753578346d6434726e414e346c755336316e5957536761754e553879646b7230624c544d59416f4959745771784d344c7445756d654552447466556a6c4d447270374c363769646479794a744f7655497532727175566e34696956534f4b585968694d534a574c77554a5a4c75513243576d566c6456344d543131556d5867423866723064583357503656484d6956727363696d364461326d4a7866667a77535532763678577a534b6d7a51346355544f61434254765767553134786b7a6a68636b4b6d2f7133776e7252416341686b73784d5a4e41647845663066524b493645387a7154314330583238636352707141556c745735707534737876354d62384234416369453362484d787a2f2b6741414141424a52553545726b4a6767673d3d266c6162656c436f6c6f723d324333323339267374796c653d666c6174266c6162656c3d5472792b69742b6f6e26636f6c6f723d333043343532" alt="Try on Compiler Explorer" data-canonical-src="https://img.shields.io/badge/-Compiler%20Explorer-brightgreen?logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAQCAYAAAAmlE46AAAACXBIWXMAAACwAAAAsAEUaqtpAAABSElEQVQokYVTsU7DMBB9QMTCEJbOMLB5oF0tRfUPIPIJZctYJkZYu3WMxNL+ARUfQKpImcPgDYnsXWBgYQl61TkYyxI3Wef37j3fnQ/6vkcsikY9AbiWq0mpbevDBmLRqDEAA4CEHMADgFRwrwDmch6X2i73RCFVHvC/WCeCMAFpC2AFoPPu5x4md4rnAN4luS61nYWSgauNU8ydkr0bLTMYAoIYtWqxM4LtEumeERDtfUjlMDrp7L67iddyyJtOvUIu2rquVn4iiVSOKXYhiMSJWLwUJZLuQ2CWmVldV4MT11UmXgB8fr0dX3WP6VHMiVrscim6Da2mJxffzwSU2v6xWzSKmzQ4cUTOaCBTvWgU14xkzjhckKm/q3wnrRAcAhksxMZNAdxEf0fRKI6E8zqT1C0X28ccRpqAUltW5pu4sxv5Mb8B4AciE3bHMxz/+gAAAABJRU5ErkJggg==&amp;labelColor=2C3239&amp;style=flat&amp;label=Try+it+on&amp;color=30C452" style="max-width: 100%;"></a></p>
<p dir="auto">Cpptrace is a simple and portable C++ stacktrace library supporting C++11 and greater on Linux, macOS, and Windows
including MinGW and Cygwin environments. The goal: Make stack traces simple for once.</p>
<p dir="auto">In addition to providing access to stack traces, cpptrace also provides a mechanism for getting stacktraces from thrown
exceptions which is immensely valuable for debugging and triaging. More info <a href="#traces-from-all-exceptions-cpptrace_try-and-cpptrace_catch">below</a>.</p>
<p dir="auto">Cpptrace also has a C API, docs <a href="docs/c-api.md">here</a>.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Table of Contents </h2><a id="user-content-table-of-contents-" class="anchor" aria-label="Permalink: Table of Contents " href="#table-of-contents-"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li><a href="#30-second-overview">30-Second Overview</a>
<ul dir="auto">
<li><a href="#cmake-fetchcontent-usage">CMake FetchContent Usage</a></li>
</ul>
</li>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#basic-usage">Basic Usage</a></li>
<li><a href="#namespace-cpptrace"><code>namespace cpptrace</code></a>
<ul dir="auto">
<li><a href="#stack-traces">Stack Traces</a></li>
<li><a href="#object-traces">Object Traces</a></li>
<li><a href="#raw-traces">Raw Traces</a></li>
<li><a href="#utilities">Utilities</a></li>
<li><a href="#formatting">Formatting</a>
<ul dir="auto">
<li><a href="#transforms">Transforms</a></li>
</ul>
</li>
<li><a href="#configuration">Configuration</a>
<ul dir="auto">
<li><a href="#logging">Logging</a></li>
</ul>
</li>
<li><a href="#traces-from-all-exceptions-cpptrace_try-and-cpptrace_catch">Traces From All Exceptions (<code>CPPTRACE_TRY</code> and <code>CPPTRACE_CATCH</code>)</a>
<ul dir="auto">
<li><a href="#removing-the-cpptrace_-prefix">Removing the <code>CPPTRACE_</code> prefix</a></li>
<li><a href="#how-it-works">How it works</a></li>
<li><a href="#performance">Performance</a></li>
</ul>
</li>
<li><a href="#rethrowing-exceptions">Rethrowing Exceptions</a></li>
<li><a href="#cpptracetry_catch"><code>cpptrace::try_catch</code></a></li>
<li><a href="#traces-from-seh-exceptions">Traces from SEH exceptions</a></li>
<li><a href="#traced-exception-objects">Traced Exception Objects</a>
<ul dir="auto">
<li><a href="#wrapping-stdexceptions">Wrapping std::exceptions</a></li>
<li><a href="#exception-handling-with-cpptrace-exception-objects">Exception handling with cpptrace exception objects</a></li>
</ul>
</li>
<li><a href="#terminate-handling">Terminate Handling</a></li>
<li><a href="#signal-safe-tracing">Signal-Safe Tracing</a></li>
<li><a href="#utility-types">Utility Types</a></li>
<li><a href="#headers">Headers</a></li>
<li><a href="#libdwarf-tuning">Libdwarf Tuning</a></li>
<li><a href="#jit-support">JIT Support</a></li>
<li><a href="#loading-libraries-at-runtime">Loading Libraries at Runtime</a></li>
</ul>
</li>
<li><a href="#abi-versioning">ABI Versioning</a></li>
<li><a href="#supported-debug-formats">Supported Debug Formats</a></li>
<li><a href="#how-to-include-the-library">How to Include The Library</a>
<ul dir="auto">
<li><a href="#cmake-fetchcontent">CMake FetchContent</a></li>
<li><a href="#system-wide-installation">System-Wide Installation</a></li>
<li><a href="#local-user-installation">Local User Installation</a></li>
<li><a href="#use-without-cmake">Use Without CMake</a></li>
<li><a href="#installation-without-package-managers-or-fetchcontent">Installation Without Package Managers or FetchContent</a></li>
<li><a href="#package-managers">Package Managers</a>
<ul dir="auto">
<li><a href="#conan">Conan</a></li>
<li><a href="#vcpkg">Vcpkg</a></li>
</ul>
</li>
<li><a href="#c20-modules">C++20 Modules</a></li>
</ul>
</li>
<li><a href="#platform-logistics">Platform Logistics</a>
<ul dir="auto">
<li><a href="#windows">Windows</a></li>
<li><a href="#macos">macOS</a></li>
</ul>
</li>
<li><a href="#library-back-ends">Library Back-Ends</a>
<ul dir="auto">
<li><a href="#summary-of-library-configurations">Summary of Library Configurations</a></li>
</ul>
</li>
<li><a href="#testing-methodology">Testing Methodology</a></li>
<li><a href="#notes-about-the-library">Notes About the Library</a></li>
<li><a href="#faq">FAQ</a>
<ul dir="auto">
<li><a href="#what-about-c23-stacktrace">What about C++23 <code>&lt;stacktrace&gt;</code>?</a></li>
<li><a href="#what-does-cpptrace-have-over-other-c-stacktrace-libraries">What does cpptrace have over other C++ stacktrace libraries?</a></li>
<li><a href="#im-getting-undefined-standard-library-symbols-like-std__1basic_string-on-macos">I'm getting undefined standard library symbols like <code>std::__1::basic_string</code> on MacOS</a></li>
</ul>
</li>
<li><a href="#contributing">Contributing</a></li>
<li><a href="#license">License</a></li>
</ul>
<div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">30-Second Overview</h1><a id="user-content-30-second-overview" class="anchor" aria-label="Permalink: 30-Second Overview" href="#30-second-overview"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Generating stack traces is as easy as:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#include &lt;cpptrace/cpptrace.hpp&gt;

void trace() {
    cpptrace::generate_trace().print();
}"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>cpptrace/cpptrace.hpp<span class="pl-pds">&gt;</span></span>

<span class="pl-k">void</span> <span class="pl-en">trace</span>() {
    <span class="pl-c1">cpptrace::generate_trace</span>().<span class="pl-c1">print</span>();
}</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="res/demo.png"><img src="res/demo.png" alt="Demo" style="max-width: 100%;"></a></p>
<p dir="auto">Cpptrace can also retrieve function inlining information on optimized release builds:</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="res/inlining.png"><img src="res/inlining.png" alt="Inlining" style="max-width: 100%;"></a></p>
<p dir="auto">Cpptrace provides access to resolved stack traces as well as fast and lightweight raw traces (just addresses) that can
be resolved later:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="const auto raw_trace = cpptrace::generate_raw_trace();
// then later
raw_trace.resolve().print();"><pre><span class="pl-k">const</span> <span class="pl-k">auto</span> raw_trace = cpptrace::generate_raw_trace();
<span class="pl-c"><span class="pl-c">//</span> then later</span>
raw_trace.resolve().print();</pre></div>
<p dir="auto">One of the most important features cpptrace offers is the ability to retrieve stack traces on arbitrary exceptions.
More information on this system <a href="(#traces-from-all-exceptions-cpptrace_try-and-cpptrace_catch)">below</a>.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#include &lt;cpptrace/from_current.hpp&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

void foo() {
    throw std::runtime_error(&quot;foo failed&quot;);
}

int main() {
    CPPTRACE_TRY {
        foo();
    } CPPTRACE_CATCH(const std::exception&amp; e) {
        std::cerr&lt;&lt;&quot;Exception: &quot;&lt;&lt;e.what()&lt;&lt;std::endl;
        cpptrace::from_current_exception().print();
    }
}"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>cpptrace/from_current.hpp<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>stdexcept<span class="pl-pds">&gt;</span></span>

<span class="pl-k">void</span> <span class="pl-en">foo</span>() {
    <span class="pl-k">throw</span> <span class="pl-smi">std::runtime_error</span>(<span class="pl-s"><span class="pl-pds">"</span>foo failed<span class="pl-pds">"</span></span>);
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {
    CPPTRACE_TRY {
        <span class="pl-c1">foo</span>();
    } <span class="pl-c1">CPPTRACE_CATCH</span>(<span class="pl-k">const</span> std::exception&amp; e) {
        std::cerr&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Exception: <span class="pl-pds">"</span></span>&lt;&lt;e.<span class="pl-c1">what</span>()&lt;&lt;std::endl;
        <span class="pl-c1">cpptrace::from_current_exception</span>().<span class="pl-c1">print</span>();
    }
}</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="res/from_current.png"><img src="res/from_current.png" alt="from_current" style="max-width: 100%;"></a></p>
<p dir="auto">Cpptrace also provides a handful of traced exception objects that store stack traces when thrown. This is useful when
the exceptions might not be caught by <code>CPPTRACE_CATCH</code>:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#include &lt;cpptrace/cpptrace.hpp&gt;

void trace() {
    throw cpptrace::logic_error(&quot;This wasn't supposed to happen!&quot;);
}"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>cpptrace/cpptrace.hpp<span class="pl-pds">&gt;</span></span>

<span class="pl-k">void</span> <span class="pl-en">trace</span>() {
    <span class="pl-k">throw</span> <span class="pl-smi">cpptrace::logic_error</span>(<span class="pl-s"><span class="pl-pds">"</span>This wasn't supposed to happen!<span class="pl-pds">"</span></span>);
}</pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="res/exception.png"><img src="res/exception.png" alt="Exception" style="max-width: 100%;"></a></p>
<p dir="auto">Additional notable features:</p>
<ul dir="auto">
<li>Utilities for demangling</li>
<li>Utilities for catching <code>std::exception</code>s and wrapping them in traced exceptions</li>
<li>Signal-safe stack tracing
<ul dir="auto">
<li>As far as I can tell cpptrace is the only library which can truly do this in a signal-safe manner</li>
</ul>
</li>
<li>Source code snippets in traces</li>
<li>Extensive configuration options for <a href="#formatting">trace formatting</a> and pretty-printing</li>
</ul>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="res/snippets.png"><img src="res/snippets.png" alt="Snippets" style="max-width: 100%;"></a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">CMake FetchContent Usage</h2><a id="user-content-cmake-fetchcontent-usage" class="anchor" aria-label="Permalink: CMake FetchContent Usage" href="#cmake-fetchcontent-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div class="highlight highlight-source-cmake notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="include(FetchContent)
FetchContent_Declare(
  cpptrace
  GIT_REPOSITORY https://github.com/jeremy-rifkin/cpptrace.git
  GIT_TAG        v1.0.4 # &lt;HASH or TAG&gt;
)
FetchContent_MakeAvailable(cpptrace)
target_link_libraries(your_target cpptrace::cpptrace)

# Needed for shared library builds on windows:  copy cpptrace.dll to the same directory as the
# executable for your_target
if(WIN32)
  add_custom_command(
    TARGET your_target POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    $&lt;TARGET_FILE:cpptrace::cpptrace&gt;
    $&lt;TARGET_FILE_DIR:your_target&gt;
  )
endif()"><pre><span class="pl-k">include</span>(FetchContent)
FetchContent_Declare(
  cpptrace
  GIT_REPOSITORY https://github.com/jeremy-rifkin/cpptrace.git
  GIT_TAG        v1.0.4 <span class="pl-c"># &lt;HASH or TAG&gt;</span>
)
FetchContent_MakeAvailable(cpptrace)
<span class="pl-k">target_link_libraries</span>(your_target cpptrace::cpptrace)

<span class="pl-c"># Needed for shared library builds on windows:  copy cpptrace.dll to the same directory as the</span>
<span class="pl-c"># executable for your_target</span>
<span class="pl-k">if</span>(<span class="pl-c1">WIN32</span>)
<span class="pl-k">  add_custom_command</span>(
    <span class="pl-k">TARGET</span> your_target POST_BUILD
    <span class="pl-k">COMMAND</span> <span class="pl-k">${CMAKE_COMMAND}</span> -E copy_if_different
    $&lt;TARGET_FILE:cpptrace::cpptrace&gt;
    $&lt;TARGET_FILE_DIR:your_target&gt;
  )
<span class="pl-k">endif</span>()</pre></div>
<p dir="auto">Be sure to configure with <code>-DCMAKE_BUILD_TYPE=Debug</code> or <code>-DCMAKE_BUILD_TYPE=RelWithDebInfo</code> for symbols and line
information.</p>
<p dir="auto">On macOS it is recommended to generate a <code>.dSYM</code> file, see <a href="#platform-logistics">Platform Logistics</a> below.</p>
<p dir="auto">For other ways to use the library, such as through package managers, a system-wide installation, or on a platform
without internet access see <a href="#how-to-include-the-library">How to Include The Library</a> below.</p>
<div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">Prerequisites</h1><a id="user-content-prerequisites" class="anchor" aria-label="Permalink: Prerequisites" href="#prerequisites"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div class="markdown-alert markdown-alert-important" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-report mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p><p dir="auto">Debug info (<code>-g</code>/<code>/Z7</code>/<code>/Zi</code>/<code>/DEBUG</code>/<code>-DBUILD_TYPE=Debug</code>/<code>-DBUILD_TYPE=RelWithDebInfo</code>) is required for complete
trace information.</p>
</div>
<div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">Basic Usage</h1><a id="user-content-basic-usage" class="anchor" aria-label="Permalink: Basic Usage" href="#basic-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>cpptrace::generate_trace()</code> can be used to generate a <code>stacktrace</code> object at the current call site. Resolved frames can
be accessed from this object with <code>.frames</code> and the trace can be printed with <code>.print()</code>. Cpptrace also provides a
method to get light-weight raw traces with <code>cpptrace::generate_raw_trace()</code>, which are just vectors of program counters,
which can be resolved at a later time.</p>
<div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto"><code>namespace cpptrace</code></h1><a id="user-content-namespace-cpptrace" class="anchor" aria-label="Permalink: namespace cpptrace" href="#namespace-cpptrace"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">All functions are thread-safe unless otherwise noted.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Stack Traces</h2><a id="user-content-stack-traces" class="anchor" aria-label="Permalink: Stack Traces" href="#stack-traces"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The core resolved stack trace object. Generate a trace with <code>cpptrace::generate_trace()</code> or
<code>cpptrace::stacktrace::current()</code>. On top of a set of helper functions <code>struct stacktrace</code> allows
direct access to frames as well as iterators.</p>
<p dir="auto"><code>cpptrace::stacktrace::print</code> can be used to print a stacktrace. <code>cpptrace::stacktrace::print_with_snippets</code> can be used
to print a stack trace with source code snippets.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace cpptrace {
    // Some type sufficient for an instruction pointer, currently always an alias to std::uintptr_t
    using frame_ptr = std::uintptr_t;

    struct stacktrace_frame {
        frame_ptr raw_address; // address in memory
        frame_ptr object_address; // address in the object file
        // nullable&lt;T&gt; represents a nullable integer. More docs later.
        nullable&lt;std::uint32_t&gt; line;
        nullable&lt;std::uint32_t&gt; column;
        std::string filename;
        std::string symbol;
        bool is_inline;
        bool operator==(const stacktrace_frame&amp; other) const;
        bool operator!=(const stacktrace_frame&amp; other) const;
        object_frame get_object_info() const; // object_address is stored but if the object_path is needed this can be used
        std::string to_string() const;
        /* operator&lt;&lt;(ostream, ..) and std::format support exist for this object */
    };

    struct stacktrace {
        std::vector&lt;stacktrace_frame&gt; frames;
        // here as a drop-in for std::stacktrace
        static stacktrace current(std::size_t skip = 0);
        static stacktrace current(std::size_t skip, std::size_t max_depth);
        void print() const;
        void print(std::ostream&amp; stream) const;
        void print(std::ostream&amp; stream, bool color) const;
        void print_with_snippets() const;
        void print_with_snippets(std::ostream&amp; stream) const;
        void print_with_snippets(std::ostream&amp; stream, bool color) const;
        std::string to_string(bool color = false) const;
        void clear();
        bool empty() const noexcept;
        /* operator&lt;&lt;(ostream, ..), std::format support, and iterators exist for this object */
    };

    stacktrace generate_trace(std::size_t skip = 0);
    stacktrace generate_trace(std::size_t skip, std::size_t max_depth);
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">cpptrace</span> {
    <span class="pl-c"><span class="pl-c">//</span> Some type sufficient for an instruction pointer, currently always an alias to std::uintptr_t</span>
    <span class="pl-k">using</span> frame_ptr = std::<span class="pl-c1">uintptr_t</span>;

    <span class="pl-k">struct</span> <span class="pl-en">stacktrace_frame</span> {
        frame_ptr raw_address; <span class="pl-c"><span class="pl-c">//</span> address in memory</span>
        frame_ptr object_address; <span class="pl-c"><span class="pl-c">//</span> address in the object file</span>
        <span class="pl-c"><span class="pl-c">//</span> nullable&lt;T&gt; represents a nullable integer. More docs later.</span>
        nullable&lt;std::<span class="pl-c1">uint32_t</span>&gt; line;
        nullable&lt;std::<span class="pl-c1">uint32_t</span>&gt; column;
        std::string filename;
        std::string symbol;
        <span class="pl-k">bool</span> is_inline;
        <span class="pl-k">bool</span> <span class="pl-k">operator</span>==(<span class="pl-k">const</span> stacktrace_frame&amp; other) <span class="pl-k">const</span>;
        <span class="pl-k">bool</span> <span class="pl-k">operator</span>!=(<span class="pl-k">const</span> stacktrace_frame&amp; other) <span class="pl-k">const</span>;
        object_frame <span class="pl-en">get_object_info</span>() <span class="pl-k">const</span>; <span class="pl-c"><span class="pl-c">//</span> object_address is stored but if the object_path is needed this can be used</span>
        std::string <span class="pl-en">to_string</span>() <span class="pl-k">const</span>;
        <span class="pl-c"><span class="pl-c">/*</span> operator&lt;&lt;(ostream, ..) and std::format support exist for this object <span class="pl-c">*/</span></span>
    };

    <span class="pl-k">struct</span> <span class="pl-en">stacktrace</span> {
        std::vector&lt;stacktrace_frame&gt; frames;
        <span class="pl-c"><span class="pl-c">//</span> here as a drop-in for std::stacktrace</span>
        <span class="pl-k">static</span> stacktrace <span class="pl-en">current</span>(std::<span class="pl-c1">size_t</span> skip = <span class="pl-c1">0</span>);
        <span class="pl-k">static</span> stacktrace <span class="pl-en">current</span>(std::<span class="pl-c1">size_t</span> skip, std::<span class="pl-c1">size_t</span> max_depth);
        <span class="pl-k">void</span> <span class="pl-en">print</span>() <span class="pl-k">const</span>;
        <span class="pl-k">void</span> <span class="pl-en">print</span>(std::ostream&amp; stream) <span class="pl-k">const</span>;
        <span class="pl-k">void</span> <span class="pl-en">print</span>(std::ostream&amp; stream, <span class="pl-k">bool</span> color) <span class="pl-k">const</span>;
        <span class="pl-k">void</span> <span class="pl-en">print_with_snippets</span>() <span class="pl-k">const</span>;
        <span class="pl-k">void</span> <span class="pl-en">print_with_snippets</span>(std::ostream&amp; stream) <span class="pl-k">const</span>;
        <span class="pl-k">void</span> <span class="pl-en">print_with_snippets</span>(std::ostream&amp; stream, <span class="pl-k">bool</span> color) <span class="pl-k">const</span>;
        std::string <span class="pl-en">to_string</span>(<span class="pl-k">bool</span> color = <span class="pl-c1">false</span>) <span class="pl-k">const</span>;
        <span class="pl-k">void</span> <span class="pl-en">clear</span>();
        <span class="pl-k">bool</span> <span class="pl-en">empty</span>() <span class="pl-k">const</span> <span class="pl-k">noexcept</span>;
        <span class="pl-c"><span class="pl-c">/*</span> operator&lt;&lt;(ostream, ..), std::format support, and iterators exist for this object <span class="pl-c">*/</span></span>
    };

    stacktrace <span class="pl-en">generate_trace</span>(std::<span class="pl-c1">size_t</span> skip = <span class="pl-c1">0</span>);
    stacktrace <span class="pl-en">generate_trace</span>(std::<span class="pl-c1">size_t</span> skip, std::<span class="pl-c1">size_t</span> max_depth);
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Object Traces</h2><a id="user-content-object-traces" class="anchor" aria-label="Permalink: Object Traces" href="#object-traces"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Object traces contain the most basic information needed to construct a stack trace outside the currently running
executable. It contains the raw address, the address in the binary (ASLR and the object file's memory space and whatnot
is resolved), and the path to the object the instruction pointer is located in.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace cpptrace {
    struct object_frame {
        std::string object_path;
        frame_ptr raw_address;
        frame_ptr object_address;
    };

    struct object_trace {
        std::vector&lt;object_frame&gt; frames;
        static object_trace current(std::size_t skip = 0);
        static object_trace current(std::size_t skip, std::size_t max_depth);
        stacktrace resolve() const;
        void clear();
        bool empty() const noexcept;
        /* iterators exist for this object */
    };

    object_trace generate_object_trace(std::size_t skip = 0);
    object_trace generate_object_trace(std::size_t skip, std::size_t max_depth);
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">cpptrace</span> {
    <span class="pl-k">struct</span> <span class="pl-en">object_frame</span> {
        std::string object_path;
        frame_ptr raw_address;
        frame_ptr object_address;
    };

    <span class="pl-k">struct</span> <span class="pl-en">object_trace</span> {
        std::vector&lt;object_frame&gt; frames;
        <span class="pl-k">static</span> object_trace <span class="pl-en">current</span>(std::<span class="pl-c1">size_t</span> skip = <span class="pl-c1">0</span>);
        <span class="pl-k">static</span> object_trace <span class="pl-en">current</span>(std::<span class="pl-c1">size_t</span> skip, std::<span class="pl-c1">size_t</span> max_depth);
        stacktrace <span class="pl-en">resolve</span>() <span class="pl-k">const</span>;
        <span class="pl-k">void</span> <span class="pl-en">clear</span>();
        <span class="pl-k">bool</span> <span class="pl-en">empty</span>() <span class="pl-k">const</span> <span class="pl-k">noexcept</span>;
        <span class="pl-c"><span class="pl-c">/*</span> iterators exist for this object <span class="pl-c">*/</span></span>
    };

    object_trace <span class="pl-en">generate_object_trace</span>(std::<span class="pl-c1">size_t</span> skip = <span class="pl-c1">0</span>);
    object_trace <span class="pl-en">generate_object_trace</span>(std::<span class="pl-c1">size_t</span> skip, std::<span class="pl-c1">size_t</span> max_depth);
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Raw Traces</h2><a id="user-content-raw-traces" class="anchor" aria-label="Permalink: Raw Traces" href="#raw-traces"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Raw trace access: A vector of program counters. These are ideal for fast and cheap traces you want to resolve later.</p>
<p dir="auto">Note it is important executables and shared libraries in memory aren't somehow unmapped otherwise libdl calls (and
<code>GetModuleFileName</code> in windows) will fail to figure out where the program counter corresponds to.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace cpptrace {
    struct raw_trace {
        std::vector&lt;frame_ptr&gt; frames;
        static raw_trace current(std::size_t skip = 0);
        static raw_trace current(std::size_t skip, std::size_t max_depth);
        object_trace resolve_object_trace() const;
        stacktrace resolve() const;
        void clear();
        bool empty() const noexcept;
        /* iterators exist for this object */
    };

    raw_trace generate_raw_trace(std::size_t skip = 0);
    raw_trace generate_raw_trace(std::size_t skip, std::size_t max_depth);
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">cpptrace</span> {
    <span class="pl-k">struct</span> <span class="pl-en">raw_trace</span> {
        std::vector&lt;frame_ptr&gt; frames;
        <span class="pl-k">static</span> raw_trace <span class="pl-en">current</span>(std::<span class="pl-c1">size_t</span> skip = <span class="pl-c1">0</span>);
        <span class="pl-k">static</span> raw_trace <span class="pl-en">current</span>(std::<span class="pl-c1">size_t</span> skip, std::<span class="pl-c1">size_t</span> max_depth);
        object_trace <span class="pl-en">resolve_object_trace</span>() <span class="pl-k">const</span>;
        stacktrace <span class="pl-en">resolve</span>() <span class="pl-k">const</span>;
        <span class="pl-k">void</span> <span class="pl-en">clear</span>();
        <span class="pl-k">bool</span> <span class="pl-en">empty</span>() <span class="pl-k">const</span> <span class="pl-k">noexcept</span>;
        <span class="pl-c"><span class="pl-c">/*</span> iterators exist for this object <span class="pl-c">*/</span></span>
    };

    raw_trace <span class="pl-en">generate_raw_trace</span>(std::<span class="pl-c1">size_t</span> skip = <span class="pl-c1">0</span>);
    raw_trace <span class="pl-en">generate_raw_trace</span>(std::<span class="pl-c1">size_t</span> skip, std::<span class="pl-c1">size_t</span> max_depth);
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Utilities</h2><a id="user-content-utilities" class="anchor" aria-label="Permalink: Utilities" href="#utilities"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>cpptrace::demangle</code> is a helper function for name demangling, since it has to implement that helper internally anyways.</p>
<p dir="auto"><code>cpptrace::basename</code> is a helper for custom formatters that extracts a base file name from a path.</p>
<p dir="auto"><code>cpptrace::prettify_symbol</code> is a helper for custom formatters that applies a number of transformations to clean up long
symbol names. For example, it turns <code>std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;</code>
into <code>std::string</code>.</p>
<p dir="auto"><code>cpptrace::prune_symbol</code> is a helper for custom formatters that prunes demangled symbols by removing return types,
template arguments, and function parameters. It also does some minimal normalization. For example, it prunes
<code>ns::S&lt;int, float&gt;::~S()</code> to <code>ns::S::~S</code>. If cpptrace is unable to parse the symbol it will return the original symbol.</p>
<p dir="auto"><code>cpptrace::get_snippet</code> gets a text snippet, if possible, from for the given source file for +/- <code>context_size</code> lines
around <code>line</code>.</p>
<p dir="auto"><code>cpptrace::isatty</code> and the fileno definitions are useful for deciding whether to use color when printing stack traces.</p>
<p dir="auto"><code>cpptrace::register_terminate_handler()</code> is a helper function to set a custom <code>std::terminate</code> handler that prints a
stack trace from a cpptrace exception (more info below) and otherwise behaves like the normal terminate handler.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace cpptrace {
    std::string demangle(const std::string&amp; name);

    std::string basename(const std::string&amp; path);

    std::string prettify_symbol(std::string symbol);
    std::string prune_symbol(const std::string&amp; symbol);

    std::string get_snippet(
        const std::string&amp; path,
        std::size_t line,
        std::size_t context_size,
        bool color = false
    );

    std::string get_snippet(
        const std::string&amp; path,
        std::size_t line,
        nullable&lt;std::uint32_t&gt; column,
        std::size_t context_size,
        bool color = false
    );

    bool isatty(int fd);

    extern const int stdin_fileno;
    extern const int stderr_fileno;
    extern const int stdout_fileno;

    void register_terminate_handler();
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">cpptrace</span> {
    std::string <span class="pl-en">demangle</span>(<span class="pl-k">const</span> std::string&amp; name);

    std::string <span class="pl-en">basename</span>(<span class="pl-k">const</span> std::string&amp; path);

    std::string <span class="pl-en">prettify_symbol</span>(std::string symbol);
    std::string <span class="pl-en">prune_symbol</span>(<span class="pl-k">const</span> std::string&amp; symbol);

    std::string <span class="pl-en">get_snippet</span>(
        <span class="pl-k">const</span> std::string&amp; path,
        std::<span class="pl-c1">size_t</span> line,
        std::<span class="pl-c1">size_t</span> context_size,
        <span class="pl-k">bool</span> color = <span class="pl-c1">false</span>
    );

    std::string <span class="pl-en">get_snippet</span>(
        <span class="pl-k">const</span> std::string&amp; path,
        std::<span class="pl-c1">size_t</span> line,
        nullable&lt;std::<span class="pl-c1">uint32_t</span>&gt; column,
        std::<span class="pl-c1">size_t</span> context_size,
        <span class="pl-k">bool</span> color = <span class="pl-c1">false</span>
    );

    <span class="pl-k">bool</span> <span class="pl-en">isatty</span>(<span class="pl-k">int</span> fd);

    <span class="pl-k">extern</span> <span class="pl-k">const</span> <span class="pl-k">int</span> stdin_fileno;
    <span class="pl-k">extern</span> <span class="pl-k">const</span> <span class="pl-k">int</span> stderr_fileno;
    <span class="pl-k">extern</span> <span class="pl-k">const</span> <span class="pl-k">int</span> stdout_fileno;

    <span class="pl-k">void</span> <span class="pl-en">register_terminate_handler</span>();
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Formatting</h2><a id="user-content-formatting" class="anchor" aria-label="Permalink: Formatting" href="#formatting"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Cpptrace provides a configurable formatter for stack trace printing which supports some common options. Formatters are
configured with a sort of builder pattern, e.g.:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="auto formatter = cpptrace::formatter{}
    .header(&quot;Stack trace:&quot;)
    .addresses(cpptrace::formatter::address_mode::object)
    .snippets(true);"><pre><span class="pl-k">auto</span> formatter = cpptrace::formatter{}
    .header(<span class="pl-s"><span class="pl-pds">"</span>Stack trace:<span class="pl-pds">"</span></span>)
    .addresses(cpptrace::formatter::address_mode::object)
    .snippets(<span class="pl-c1">true</span>);</pre></div>
<p dir="auto">This API is available through the <code>&lt;cpptrace/formatting.hpp&gt;</code> header.</p>
<p dir="auto">Synopsis:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace cpptrace {
    class formatter {
        formatter&amp; header(std::string);
        enum class color_mode { always, none, automatic };
        formatter&amp; colors(color_mode);
        enum class address_mode { raw, object, none };
        formatter&amp; addresses(address_mode);
        enum class path_mode { full, basename };
        formatter&amp; paths(path_mode);
        formatter&amp; snippets(bool);
        formatter&amp; snippet_context(int);
        formatter&amp; columns(bool);
        enum class symbol_mode { full, pretty, pruned };
        formatter&amp; symbols(symbol_mode);
        formatter&amp; filtered_frame_placeholders(bool);
        formatter&amp; filter(std::function&lt;bool(const stacktrace_frame&amp;)&gt;);
        formatter&amp; transform(std::function&lt;stacktrace_frame(stacktrace_frame)&gt;);
        formatter&amp; break_before_filename(bool do_break = true);
        formatter&amp; hide_exception_machinery(bool do_hide = true);

        std::string format(const stacktrace_frame&amp;) const;
        std::string format(const stacktrace_frame&amp;, bool color) const;

        std::string format(const stacktrace&amp;) const;
        std::string format(const stacktrace&amp;, bool color) const;

        void print(const stacktrace_frame&amp;) const;
        void print(const stacktrace_frame&amp;, bool color) const;
        void print(std::ostream&amp;, const stacktrace_frame&amp;) const;
        void print(std::ostream&amp;, const stacktrace_frame&amp;, bool color) const;
        void print(std::FILE*, const stacktrace_frame&amp;) const;
        void print(std::FILE*, const stacktrace_frame&amp;, bool color) const;

        void print(const stacktrace&amp;) const;
        void print(const stacktrace&amp;, bool color) const;
        void print(std::ostream&amp;, const stacktrace&amp;) const;
        void print(std::ostream&amp;, const stacktrace&amp;, bool color) const;
        void print(std::FILE*, const stacktrace&amp;) const;
        void print(std::FILE*, const stacktrace&amp;, bool color) const;
    };
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">cpptrace</span> {
    <span class="pl-k">class</span> <span class="pl-en">formatter</span> {
        formatter&amp; <span class="pl-en">header</span>(std::string);
        <span class="pl-k">enum</span> <span class="pl-k">class</span> <span class="pl-en">color_mode</span> { always, none, automatic };
        formatter&amp; <span class="pl-en">colors</span>(color_mode);
        <span class="pl-k">enum</span> <span class="pl-k">class</span> <span class="pl-en">address_mode</span> { raw, object, none };
        formatter&amp; <span class="pl-en">addresses</span>(address_mode);
        <span class="pl-k">enum</span> <span class="pl-k">class</span> <span class="pl-en">path_mode</span> { full, basename };
        formatter&amp; <span class="pl-en">paths</span>(path_mode);
        formatter&amp; <span class="pl-en">snippets</span>(<span class="pl-k">bool</span>);
        formatter&amp; <span class="pl-en">snippet_context</span>(<span class="pl-k">int</span>);
        formatter&amp; <span class="pl-en">columns</span>(<span class="pl-k">bool</span>);
        <span class="pl-k">enum</span> <span class="pl-k">class</span> <span class="pl-en">symbol_mode</span> { full, pretty, pruned };
        formatter&amp; <span class="pl-en">symbols</span>(symbol_mode);
        formatter&amp; <span class="pl-en">filtered_frame_placeholders</span>(<span class="pl-k">bool</span>);
        formatter&amp; <span class="pl-en">filter</span>(std::function&lt;<span class="pl-k">bool</span>(<span class="pl-k">const</span> stacktrace_frame&amp;)&gt;);
        formatter&amp; <span class="pl-en">transform</span>(std::function&lt;stacktrace_frame(stacktrace_frame)&gt;);
        formatter&amp; <span class="pl-en">break_before_filename</span>(<span class="pl-k">bool</span> do_break = <span class="pl-c1">true</span>);
        formatter&amp; <span class="pl-en">hide_exception_machinery</span>(<span class="pl-k">bool</span> do_hide = <span class="pl-c1">true</span>);

        std::string <span class="pl-en">format</span>(<span class="pl-k">const</span> stacktrace_frame&amp;) <span class="pl-k">const</span>;
        std::string <span class="pl-en">format</span>(<span class="pl-k">const</span> stacktrace_frame&amp;, <span class="pl-k">bool</span> color) <span class="pl-k">const</span>;

        std::string <span class="pl-en">format</span>(<span class="pl-k">const</span> stacktrace&amp;) <span class="pl-k">const</span>;
        std::string <span class="pl-en">format</span>(<span class="pl-k">const</span> stacktrace&amp;, <span class="pl-k">bool</span> color) <span class="pl-k">const</span>;

        <span class="pl-k">void</span> <span class="pl-en">print</span>(<span class="pl-k">const</span> stacktrace_frame&amp;) <span class="pl-k">const</span>;
        <span class="pl-k">void</span> <span class="pl-en">print</span>(<span class="pl-k">const</span> stacktrace_frame&amp;, <span class="pl-k">bool</span> color) <span class="pl-k">const</span>;
        <span class="pl-k">void</span> <span class="pl-en">print</span>(std::ostream&amp;, <span class="pl-k">const</span> stacktrace_frame&amp;) <span class="pl-k">const</span>;
        <span class="pl-k">void</span> <span class="pl-en">print</span>(std::ostream&amp;, <span class="pl-k">const</span> stacktrace_frame&amp;, <span class="pl-k">bool</span> color) <span class="pl-k">const</span>;
        <span class="pl-k">void</span> <span class="pl-en">print</span>(std::FILE*, <span class="pl-k">const</span> stacktrace_frame&amp;) <span class="pl-k">const</span>;
        <span class="pl-k">void</span> <span class="pl-en">print</span>(std::FILE*, <span class="pl-k">const</span> stacktrace_frame&amp;, <span class="pl-k">bool</span> color) <span class="pl-k">const</span>;

        <span class="pl-k">void</span> <span class="pl-en">print</span>(<span class="pl-k">const</span> stacktrace&amp;) <span class="pl-k">const</span>;
        <span class="pl-k">void</span> <span class="pl-en">print</span>(<span class="pl-k">const</span> stacktrace&amp;, <span class="pl-k">bool</span> color) <span class="pl-k">const</span>;
        <span class="pl-k">void</span> <span class="pl-en">print</span>(std::ostream&amp;, <span class="pl-k">const</span> stacktrace&amp;) <span class="pl-k">const</span>;
        <span class="pl-k">void</span> <span class="pl-en">print</span>(std::ostream&amp;, <span class="pl-k">const</span> stacktrace&amp;, <span class="pl-k">bool</span> color) <span class="pl-k">const</span>;
        <span class="pl-k">void</span> <span class="pl-en">print</span>(std::FILE*, <span class="pl-k">const</span> stacktrace&amp;) <span class="pl-k">const</span>;
        <span class="pl-k">void</span> <span class="pl-en">print</span>(std::FILE*, <span class="pl-k">const</span> stacktrace&amp;, <span class="pl-k">bool</span> color) <span class="pl-k">const</span>;
    };
}</pre></div>
<p dir="auto">Options:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Setting</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>header</code></td>
<td>Header line printed before the trace</td>
<td><code>Stack trace (most recent call first):</code></td>
</tr>
<tr>
<td><code>colors</code></td>
<td>Default color mode for the trace</td>
<td><code>automatic</code>, which attempts to detect if the target stream is a terminal</td>
</tr>
<tr>
<td><code>addresses</code></td>
<td>Raw addresses, object addresses, or no addresses</td>
<td><code>raw</code></td>
</tr>
<tr>
<td><code>paths</code></td>
<td>Full paths or just filenames</td>
<td><code>full</code></td>
</tr>
<tr>
<td><code>snippets</code></td>
<td>Whether to include source code snippets</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>snippet_context</code></td>
<td>How many lines of source context to show in a snippet</td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>columns</code></td>
<td>Whether to include column numbers if present</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>symbols</code></td>
<td>Full demangled symbols, pruned symbol names, or prettified symbols</td>
<td><code>full</code></td>
</tr>
<tr>
<td><code>filtered_frame_placeholders</code></td>
<td>Whether to still print filtered frames as just <code>#n (filtered)</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>filter</code></td>
<td>A predicate to filter frames with</td>
<td>None</td>
</tr>
<tr>
<td><code>transform</code></td>
<td>A transformer which takes a stacktrace frame and modifies it</td>
<td>None</td>
</tr>
<tr>
<td><code>break_before_filename</code></td>
<td>Print symbol and line source location on different lines</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>hide_exception_machinery</code></td>
<td>Hide exception internals for current exception traces</td>
<td><code>true</code></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">The <code>automatic</code> color mode attempts to detect if a stream that may be attached to a terminal. As such, it will not use
colors for the <code>formatter::format</code> method and it may not be able to detect if some ostreams correspond to terminals or
not. For this reason, <code>formatter::format</code> and <code>formatter::print</code> methods have overloads taking a color parameter. This
color parameter will override configured color mode.</p>
<p dir="auto">The <code>symbols</code> option provides a few settings for pretty-printing symbol names:</p>
<ul dir="auto">
<li><code>symbol_mode::full</code> default, uses the full demangled name</li>
<li><code>symbol_mode::pretty</code> applies a number of transformations to clean up long symbol names. For example, it turns
<code>std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;</code> into <code>std::string</code>. This is
equivalent to <code>cpptrace::prettify_symbol</code>.</li>
<li><code>symbol_mode::pruned</code> prunes demangled symbols by removing return types, template arguments, and function parameters.
It also does some minimal normalization. For example, it prunes <code>ns::S&lt;int, float&gt;::~S()</code> to <code>ns::S::~S</code>. If cpptrace
is unable to parse the symbol it will use the full symbol. This is equivalent to <code>cpptrace::prune_symbol</code>.</li>
</ul>
<p dir="auto">Recommended practice with formatters: It's generally preferable to create formatters objects that are long-lived rather
than to create them on the fly every time a trace needs to be formatted.</p>
<p dir="auto">Cpptrace provides access to a formatter with default settings with <code>get_default_formatter</code>:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace cpptrace {
    const formatter&amp; get_default_formatter();
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">cpptrace</span> {
    <span class="pl-k">const</span> formatter&amp; <span class="pl-en">get_default_formatter</span>();
}</pre></div>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">Transforms</h3><a id="user-content-transforms" class="anchor" aria-label="Permalink: Transforms" href="#transforms"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">A transform function can be specified for the formatter. This function is called before the configured <code>filter</code> is
checked. For example:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="auto formatter = cpptrace::formatter{}
    .transform([](cpptrace::stacktrace_frame frame) {
        frame.symbol = replace_all(frame, &quot;std::__cxx11::&quot;, &quot;std::&quot;);
        return frame;
    });"><pre><span class="pl-k">auto</span> formatter = cpptrace::formatter{}
    .transform([](cpptrace::stacktrace_frame frame) {
        frame.<span class="pl-smi">symbol</span> = <span class="pl-c1">replace_all</span>(frame, <span class="pl-s"><span class="pl-pds">"</span>std::__cxx11::<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>std::<span class="pl-pds">"</span></span>);
        <span class="pl-k">return</span> frame;
    });</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Configuration</h2><a id="user-content-configuration" class="anchor" aria-label="Permalink: Configuration" href="#configuration"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>cpptrace::absorb_trace_exceptions</code>: Configure whether the library silently absorbs internal exceptions and continues.
Default is true.</p>
<p dir="auto"><code>cpptrace::enable_inlined_call_resolution</code>: Configure whether the library will attempt to resolve inlined call
information for release builds. Default is true.</p>
<p dir="auto"><code>cpptrace::experimental::set_cache_mode</code>: Control time-memory tradeoffs within the library. By default speed is
prioritized. If using this function, set the cache mode at the very start of your program before any traces are
performed.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace cpptrace {
    void absorb_trace_exceptions(bool absorb);
    void enable_inlined_call_resolution(bool enable);

    enum class cache_mode {
        // Only minimal lookup tables
        prioritize_memory,
        // Build lookup tables but don't keep them around between trace calls
        hybrid,
        // Build lookup tables as needed
        prioritize_speed
    };

    namespace experimental {
        void set_cache_mode(cache_mode mode);
    }
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">cpptrace</span> {
    <span class="pl-k">void</span> <span class="pl-en">absorb_trace_exceptions</span>(<span class="pl-k">bool</span> absorb);
    <span class="pl-k">void</span> <span class="pl-en">enable_inlined_call_resolution</span>(<span class="pl-k">bool</span> enable);

    <span class="pl-k">enum</span> <span class="pl-k">class</span> <span class="pl-en">cache_mode</span> {
        <span class="pl-c"><span class="pl-c">//</span> Only minimal lookup tables</span>
        prioritize_memory,
        <span class="pl-c"><span class="pl-c">//</span> Build lookup tables but don't keep them around between trace calls</span>
        hybrid,
        <span class="pl-c"><span class="pl-c">//</span> Build lookup tables as needed</span>
        prioritize_speed
    };

    <span class="pl-k">namespace</span> <span class="pl-en">experimental</span> {
        <span class="pl-k">void</span> <span class="pl-en">set_cache_mode</span>(cache_mode mode);
    }
}</pre></div>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">Logging</h3><a id="user-content-logging" class="anchor" aria-label="Permalink: Logging" href="#logging"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Cpptrace attempts to gracefully recover from any internal errors in order to provide the best information it can and not
interfere with user applications. However, sometimes it's important to see what's going wrong inside cpptrace if
anything does go wrong. To facilitate this, cpptrace has an internal logger. By default it doesn't log anything out. The
following configurations that can be used to set a custom logging callback or enable logging to stderr:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace cpptrace {
    enum class log_level { debug, info, warning, error };
    void set_log_level(log_level level);
    void set_log_callback(std::function&lt;void(log_level, const char*)&gt;);
    void use_default_stderr_logger();
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">cpptrace</span> {
    <span class="pl-k">enum</span> <span class="pl-k">class</span> <span class="pl-en">log_level</span> { debug, info, warning, error };
    <span class="pl-k">void</span> <span class="pl-en">set_log_level</span>(log_level level);
    <span class="pl-k">void</span> <span class="pl-en">set_log_callback</span>(std::function&lt;<span class="pl-k">void</span>(log_level, <span class="pl-k">const</span> <span class="pl-k">char</span>*)&gt;);
    <span class="pl-k">void</span> <span class="pl-en">use_default_stderr_logger</span>();
}</pre></div>
<p dir="auto"><code>cpptrace::set_log_level</code>: Set cpptrace's internal log level. Default: <code>error</code>. Cpptrace currently only uses this log
level internally.</p>
<p dir="auto"><code>cpptrace::set_log_callback</code>: Set the callback cpptrace uses for logging messages, useful for custom loggers.</p>
<p dir="auto"><code>cpptrace::use_default_stderr_logger</code>: Set's the logging callback to print to stderr.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Traces From All Exceptions (<code>CPPTRACE_TRY</code> and <code>CPPTRACE_CATCH</code>)</h2><a id="user-content-traces-from-all-exceptions-cpptrace_try-and-cpptrace_catch" class="anchor" aria-label="Permalink: Traces From All Exceptions (CPPTRACE_TRY and CPPTRACE_CATCH)" href="#traces-from-all-exceptions-cpptrace_try-and-cpptrace_catch"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Cpptrace provides <code>CPPTRACE_TRY</code> and <code>CPPTRACE_CATCH</code> macros that allow a stack trace to be collected from the current
thrown exception object, with no overhead in the non-throwing (happy) path:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#include &lt;cpptrace/from_current.hpp&gt;
#include &lt;iostream&gt;

void foo() {
    throw std::runtime_error(&quot;foo failed&quot;);
}
int main() {
    CPPTRACE_TRY {
        foo();
    } CPPTRACE_CATCH(const std::exception&amp; e) {
        std::cerr&lt;&lt;&quot;Exception: &quot;&lt;&lt;e.what()&lt;&lt;std::endl;
        cpptrace::from_current_exception().print();
    }
}"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>cpptrace/from_current.hpp<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>

<span class="pl-k">void</span> <span class="pl-en">foo</span>() {
    <span class="pl-k">throw</span> <span class="pl-smi">std::runtime_error</span>(<span class="pl-s"><span class="pl-pds">"</span>foo failed<span class="pl-pds">"</span></span>);
}
<span class="pl-k">int</span> <span class="pl-en">main</span>() {
    CPPTRACE_TRY {
        <span class="pl-c1">foo</span>();
    } <span class="pl-c1">CPPTRACE_CATCH</span>(<span class="pl-k">const</span> std::exception&amp; e) {
        std::cerr&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Exception: <span class="pl-pds">"</span></span>&lt;&lt;e.<span class="pl-c1">what</span>()&lt;&lt;std::endl;
        <span class="pl-c1">cpptrace::from_current_exception</span>().<span class="pl-c1">print</span>();
    }
}</pre></div>
<p dir="auto">This functionality is entirely opt-in, to access this use <code>#include &lt;cpptrace/from_current.hpp&gt;</code>.</p>
<p dir="auto">Any declarator <code>catch</code> accepts works with <code>CPPTRACE_CATCH</code>, including <code>...</code>. This works with any thrown object, not just
<code>std::exceptions</code>. It even works with <code>throw 0;</code>!</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="res/from_current.png"><img src="res/from_current.png" alt="from_current" style="max-width: 100%;"></a></p>
<p dir="auto">API functions:</p>
<ul dir="auto">
<li><code>cpptrace::raw_trace_from_current_exception</code>: Returns <code>const raw_trace&amp;</code> from the current exception.</li>
<li><code>cpptrace::from_current_exception</code>: Returns a resolved <code>const stacktrace&amp;</code> from the current exception. Invalidates
references to traces returned by <code>cpptrace::raw_trace_from_current_exception</code>.</li>
</ul>
<p dir="auto">In order to provide stack traces, cpptrace has to do some magic to be able to intercept C++ exception handling internals
before the stack is unwound. For a simple <code>try</code>/<code>catch</code>, <code>CPPTRACE_TRY</code>/<code>CPPTRACE_CATCH</code> macros can be used. For a
<code>try</code>/<code>catch</code> that has multiple handlers, <code>cpptrace::try_catch</code> can be used. I wish I could make a macro work, however,
for multiple handlers this is the best way for cpptrace to inject the appropriate magic. E.g.:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="cpptrace::try_catch(
    [&amp;] { // try block
        foo();
    },
    [&amp;] (const std::runtime_error&amp; e) {
        std::cerr&lt;&lt;&quot;Runtime error: &quot;&lt;&lt;e.what()&lt;&lt;std::endl;
        cpptrace::from_current_exception().print();
    },
    [&amp;] (const std::exception&amp; e) {
        std::cerr&lt;&lt;&quot;Exception: &quot;&lt;&lt;e.what()&lt;&lt;std::endl;
        cpptrace::from_current_exception().print();
    },
    [&amp;] () { // serves the same role as `catch(...)`, an any exception handler
        std::cerr&lt;&lt;&quot;Unknown exception occurred: &quot;&lt;&lt;std::endl;
        cpptrace::from_current_exception().print();
    }
);"><pre><span class="pl-en">cpptrace::try_catch</span>(
    [&amp;] { <span class="pl-c"><span class="pl-c">//</span> try block</span>
        <span class="pl-c1">foo</span>();
    },
    [&amp;] (<span class="pl-k">const</span> std::runtime_error&amp; e) {
        std::cerr&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Runtime error: <span class="pl-pds">"</span></span>&lt;&lt;e.<span class="pl-c1">what</span>()&lt;&lt;std::endl;
        <span class="pl-c1">cpptrace::from_current_exception</span>().<span class="pl-c1">print</span>();
    },
    [&amp;] (<span class="pl-k">const</span> std::exception&amp; e) {
        std::cerr&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Exception: <span class="pl-pds">"</span></span>&lt;&lt;e.<span class="pl-c1">what</span>()&lt;&lt;std::endl;
        <span class="pl-c1">cpptrace::from_current_exception</span>().<span class="pl-c1">print</span>();
    },
    [&amp;] () { <span class="pl-c"><span class="pl-c">//</span> serves the same role as `catch(...)`, an any exception handler</span>
        std::cerr&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Unknown exception occurred: <span class="pl-pds">"</span></span>&lt;&lt;std::endl;
        <span class="pl-c1">cpptrace::from_current_exception</span>().<span class="pl-c1">print</span>();
    }
);</pre></div>
<p dir="auto">Note: The current exception is the exception most recently seen by a cpptrace try-catch macro block.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="CPPTRACE_TRY {
    throw std::runtime_error(&quot;foo&quot;);
} CPPTRACE_CATCH(const std::exception&amp; e) {
    cpptrace::from_current_exception().print(); // the trace for std::runtime_error(&quot;foo&quot;)
    CPPTRACE_TRY {
        throw std::runtime_error(&quot;bar&quot;);
    } CPPTRACE_CATCH(const std::exception&amp; e) {
        cpptrace::from_current_exception().print(); // the trace for std::runtime_error(&quot;bar&quot;)
    }
    cpptrace::from_current_exception().print(); // the trace for std::runtime_error(&quot;bar&quot;), again
}"><pre>CPPTRACE_TRY {
    <span class="pl-k">throw</span> <span class="pl-smi">std::runtime_error</span>(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>);
} CPPTRACE_CATCH(<span class="pl-k">const</span> std::exception&amp; e) {
    <span class="pl-c1">cpptrace::from_current_exception</span>().<span class="pl-c1">print</span>(); <span class="pl-c"><span class="pl-c">//</span> the trace for std::runtime_error("foo")</span>
    CPPTRACE_TRY {
        <span class="pl-k">throw</span> <span class="pl-smi">std::runtime_error</span>(<span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>);
    } <span class="pl-c1">CPPTRACE_CATCH</span>(<span class="pl-k">const</span> std::exception&amp; e) {
        <span class="pl-c1">cpptrace::from_current_exception</span>().<span class="pl-c1">print</span>(); <span class="pl-c"><span class="pl-c">//</span> the trace for std::runtime_error("bar")</span>
    }
    <span class="pl-c1">cpptrace::from_current_exception</span>().<span class="pl-c1">print</span>(); <span class="pl-c"><span class="pl-c">//</span> the trace for std::runtime_error("bar"), again</span>
}</pre></div>
<p dir="auto">Note: Internally the trace contains some extra frames for calls like <code>__cxa_throw</code>, <code>_UnwindRaiseException</code>, etc. These
are filtered out during stacktrace printing but they will be present if you manually inspect the vector of stacktrace
frames.</p>
<div class="markdown-alert markdown-alert-important" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-report mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p><p dir="auto">There is an unfortunate limitation with <code>return</code> statements in these try/catch macros: The implementation on Windows
requires wrapping the try body in an immediately-invoked lambda and as such <code>return</code> statements would return from the
lambda not the enclosing function. Cpptrace guards against misleading <code>return</code>s compiling by requiring the lambdas to
return a special internal type, but, if you're writing code that will be compiled on windows it's important to not
write <code>return</code> statements within CPPTRACE_TRY. For example, this is invalid:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="CPPTRACE_TRY {
    if(condition) return 40; // error, type int doesn't match cpptrace::detail::dont_return_from_try_catch_macros
} CPPTRACE_CATCH(const std::exception&amp; e) {
    ...
}"><pre>CPPTRACE_TRY {
    <span class="pl-k">if</span>(condition) <span class="pl-k">return</span> <span class="pl-c1">40</span>; <span class="pl-c"><span class="pl-c">//</span> error, type int doesn't match cpptrace::detail::dont_return_from_try_catch_macros</span>
} CPPTRACE_CATCH(<span class="pl-k">const</span> std::exception&amp; e) {
    ...
}</pre></div>
</div>
<div class="markdown-alert markdown-alert-important" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-report mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p><p dir="auto">There is a footgun which is mainly relevant for code that was written on an older version of cpptrace: It's possible
to write the following without getting errors</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="CPPTRACE_TRY {
    ...
} CPPTRACE_CATCH(const std::runtime_error&amp; e) {
    ...
} catch(const std::exception&amp; e) {
    ...
}"><pre>CPPTRACE_TRY {
    ...
} CPPTRACE_CATCH(<span class="pl-k">const</span> std::runtime_error&amp; e) {
    ...
} <span class="pl-k">catch</span>(<span class="pl-k">const</span> std::exception&amp; e) {
    ...
}</pre></div>
<p dir="auto">This code will compile and the second catch handler will work, however, cpptrace won't know about the handler and as
such it won't be able to correctly collect a trace when a type that does not match <code>std::runtime_error</code> is thrown. No
run-time errors will occur, however, <code>from_current_exception</code> will report a misleading trace.</p>
</div>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">Removing the <code>CPPTRACE_</code> prefix</h3><a id="user-content-removing-the-cpptrace_-prefix" class="anchor" aria-label="Permalink: Removing the CPPTRACE_ prefix" href="#removing-the-cpptrace_-prefix"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>CPPTRACE_TRY</code> is a little cumbersome to type. To remove the <code>CPPTRACE_</code> prefix you can use the
<code>CPPTRACE_UNPREFIXED_TRY_CATCH</code> cmake option or the <code>CPPTRACE_UNPREFIXED_TRY_CATCH</code> preprocessor definition:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="TRY {
    foo();
} CATCH(const std::exception&amp; e) {
    std::cerr&lt;&lt;&quot;Exception: &quot;&lt;&lt;e.what()&lt;&lt;std::endl;
    cpptrace::from_current_exception().print();
}"><pre>TRY {
    <span class="pl-c1">foo</span>();
} CATCH(<span class="pl-k">const</span> std::exception&amp; e) {
    std::cerr&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Exception: <span class="pl-pds">"</span></span>&lt;&lt;e.<span class="pl-c1">what</span>()&lt;&lt;std::endl;
    <span class="pl-c1">cpptrace::from_current_exception</span>().<span class="pl-c1">print</span>();
}</pre></div>
<p dir="auto">This is not done by default for macro safety/hygiene reasons. If you do not want <code>TRY</code>/<code>CATCH</code> macros defined, as they
are common macro names, you can easily modify the following snippet to provide your own aliases:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#define TRY CPPTRACE_TRY
#define CATCH(param) CPPTRACE_CATCH(param)"><pre>#<span class="pl-k">define</span> <span class="pl-en">TRY</span> CPPTRACE_TRY
#<span class="pl-k">define</span> <span class="pl-en">CATCH</span>(<span class="pl-v">param</span>) CPPTRACE_CATCH(param)</pre></div>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">How it works</h3><a id="user-content-how-it-works" class="anchor" aria-label="Permalink: How it works" href="#how-it-works"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">C++ does not provide any language support for collecting stack traces when exceptions are thrown, however, exception
handling under both the Itanium ABI and by SEH (used to implement C++ exceptions on Windows) involves unwinding the
stack twice. The first unwind searches for an appropriate <code>catch</code> handler, the second actually unwinds the stack and
calls destructors. Since the stack remains intact during the search phase it's possible to collect a stack trace with
little to no overhead when the <code>catch</code> is considered for matching the exception. The try/catch macros for cpptrace set
up a special try/catch system that can collect a stack trace when considered during a search phase.</p>
<p dir="auto">On Windows, cpptrace's try/catch macros expand along the lines of:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<td>
Source
</td>
<td>
Expansion
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="CPPTRACE_TRY {
    foo();
} CPPTRACE_CATCH(const std::exception&amp; e) {
    ...
}"><pre>CPPTRACE_TRY {
    <span class="pl-c1">foo</span>();
} CPPTRACE_CATCH(<span class="pl-k">const</span> std::exception&amp; e) {
    ...
}</pre></div>
</td>
<td>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="try {
    [&amp;]() {
        __try {
            [&amp;]() {
                foo();
            }();
        } __except(exception_filter&lt;const std::exception&amp;&gt;(
            GetExceptionInformation()
        )) {}
    }();
} catch(const std::exception&amp; e) {
    ...
}"><pre><span class="pl-k">try</span> {
    [&amp;]() {
        __try {
            [&amp;]() {
                <span class="pl-c1">foo</span>();
            }();
        } <span class="pl-c1">__except</span>(exception_filter&lt;<span class="pl-k">const</span> std::exception&amp;&gt;(
            <span class="pl-c1">GetExceptionInformation</span>()
        )) {}
    }();
} <span class="pl-k">catch</span>(<span class="pl-k">const</span> std::exception&amp; e) {
    ...
}</pre></div>
</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">SEH's design actually makes it fairly easy to run code during the search phase. The exception filter will collect a
trace if it detects the catch will match. Unfortunately, MSVC does not allow mixing C++ <code>try</code>/<code>catch</code> and SEH
<code>__try</code>/<code>__except</code> in the same function so a double-IILE is needed. This has implications for returning from try blocks.</p>
<p dir="auto">On systems which use the Itanium ABI (linux, mac, etc), cpptrace's try/catch macros expand along the lines of:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<td>
Source
</td>
<td>
Expansion
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="CPPTRACE_TRY {
    foo();
} CPPTRACE_CATCH(const std::exception&amp; e) {
    ...
}"><pre>CPPTRACE_TRY {
    <span class="pl-c1">foo</span>();
} CPPTRACE_CATCH(<span class="pl-k">const</span> std::exception&amp; e) {
    ...
}</pre></div>
</td>
<td>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="try {
    try {
        foo();
    } catch(const unwind_interceptor_for&lt;const std::exception&amp;&gt;&amp;) {...}
} catch(const std::exception&amp; e) {
    ...
}"><pre><span class="pl-k">try</span> {
    <span class="pl-k">try</span> {
        <span class="pl-c1">foo</span>();
    } <span class="pl-k">catch</span>(<span class="pl-k">const</span> unwind_interceptor_for&lt;<span class="pl-k">const</span> std::exception&amp;&gt;&amp;) {...}
} <span class="pl-k">catch</span>(<span class="pl-k">const</span> std::exception&amp; e) {
    ...
}</pre></div>
</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">Cpptrace does some magic to hook vtables of <code>unwind_interceptor_for&lt;T&gt;</code> type_info objects during static-init time.</p>
<p dir="auto">N.b.: This mechanism is also discussed in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2490r3.html" rel="nofollow">P2490R3</a>.</p>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">Performance</h3><a id="user-content-performance" class="anchor" aria-label="Permalink: Performance" href="#performance"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The performance impact in the non-throwing happy path is zero (or as close to zero as practical) on modern
architectures.</p>
<p dir="auto">In the unhappy throwing path, a little more work may be done during the search phase to consider handlers cpptrace
inserts but this is low-impact. Generating the trace itself is fast: Cpptrace collects a raw trace during exception
handling and it is resolved only when requested. In my benchmarking I have found generation of raw traces to take on the
order of <code>100ns</code> per frame.</p>
<p dir="auto">On some older architectures/ABIs (e.g., 32-bit windows), <code>try</code>/<code>catch</code> itself has some overhead due to how it is
implemented with SEH. Cpptrace's <code>try</code>/<code>catch</code> macro adds one extra layer of handler which may be relevant on such
systems but should not be a problem outside of hot loops, where using any <code>try</code>/<code>catch</code> is presumably already a problem
on such architectures.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Rethrowing Exceptions</h2><a id="user-content-rethrowing-exceptions" class="anchor" aria-label="Permalink: Rethrowing Exceptions" href="#rethrowing-exceptions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">By default <code>cpptrace::from_current_exception</code> will correspond to a trace for the last <code>throw</code> intercepted by a
<code>CPPTRACE_CATCH</code>. In order to rethrow an exception while preserving the original trace, <code>cpptrace::rethrow()</code> can be
used.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace cpptrace {
    void rethrow();
    void rethrow(std::exception_ptr exception = std::current_exception());
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">cpptrace</span> {
    <span class="pl-k">void</span> <span class="pl-en">rethrow</span>();
    <span class="pl-k">void</span> <span class="pl-en">rethrow</span>(std::exception_ptr exception = std::current_exception());
}</pre></div>
<div class="markdown-alert markdown-alert-note" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p dir="auto">It's important to use <code>cpptrace::rethrow()</code> from within a <code>CPPTRACE_CATCH</code>. If it is not, then no trace for the
exception origin will have been collected.</p>
</div>
<p dir="auto">Example:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="void bar() {
    throw std::runtime_error(&quot;critical error in bar&quot;);
}
void foo() {
    CPPTRACE_TRY {
        bar();
    } CPPTRACE_CATCH(const std::exception&amp; e) {
        std::cerr&lt;&lt;&quot;Exception in foo: &quot;&lt;&lt;e.what()&lt;&lt;std::endl;
        cpptrace::rethrow();
    }
}
int main() {
    CPPTRACE_TRY {
        foo();
    } CPPTRACE_CATCH(const std::exception&amp; e) {
        std::cerr&lt;&lt;&quot;Exception encountered while running foo: &quot;&lt;&lt;e.what()&lt;&lt;std::endl;
        cpptrace::from_current_exception().print(); // prints trace containing main -&gt; foo -&gt; bar
    }
}"><pre><span class="pl-k">void</span> <span class="pl-en">bar</span>() {
    <span class="pl-k">throw</span> <span class="pl-smi">std::runtime_error</span>(<span class="pl-s"><span class="pl-pds">"</span>critical error in bar<span class="pl-pds">"</span></span>);
}
<span class="pl-k">void</span> <span class="pl-en">foo</span>() {
    CPPTRACE_TRY {
        <span class="pl-c1">bar</span>();
    } <span class="pl-c1">CPPTRACE_CATCH</span>(<span class="pl-k">const</span> std::exception&amp; e) {
        std::cerr&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Exception in foo: <span class="pl-pds">"</span></span>&lt;&lt;e.<span class="pl-c1">what</span>()&lt;&lt;std::endl;
        <span class="pl-c1">cpptrace::rethrow</span>();
    }
}
<span class="pl-k">int</span> <span class="pl-en">main</span>() {
    CPPTRACE_TRY {
        <span class="pl-c1">foo</span>();
    } <span class="pl-c1">CPPTRACE_CATCH</span>(<span class="pl-k">const</span> std::exception&amp; e) {
        std::cerr&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Exception encountered while running foo: <span class="pl-pds">"</span></span>&lt;&lt;e.<span class="pl-c1">what</span>()&lt;&lt;std::endl;
        <span class="pl-c1">cpptrace::from_current_exception</span>().<span class="pl-c1">print</span>(); <span class="pl-c"><span class="pl-c">//</span> prints trace containing main -&gt; foo -&gt; bar</span>
    }
}</pre></div>
<p dir="auto">Sometimes it may be desirable to see both the trace for the exception's origin as well as the trace for where it was
rethrown. Cpptrace provides an interface for getting the last rethrow location:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace cpptrace {
    const raw_trace&amp; raw_trace_from_current_exception_rethrow();
    const stacktrace&amp; from_current_exception_rethrow();
    bool current_exception_was_rethrown();
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">cpptrace</span> {
    <span class="pl-k">const</span> raw_trace&amp; <span class="pl-en">raw_trace_from_current_exception_rethrow</span>();
    <span class="pl-k">const</span> stacktrace&amp; <span class="pl-en">from_current_exception_rethrow</span>();
    <span class="pl-k">bool</span> <span class="pl-en">current_exception_was_rethrown</span>();
}</pre></div>
<p dir="auto">If the current exception was not rethrown, these functions return references to empty traces.
<code>current_exception_was_rethrown</code> can be used to check if the current exception was rethrown and a non-empty rethrow
trace exists.</p>
<p dir="auto">Example usage, utilizing <code>foo</code> and <code>bar</code> from the above example:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="int main() {
    CPPTRACE_TRY {
        foo();
    } CPPTRACE_CATCH(const std::exception&amp; e) {
        std::cerr&lt;&lt;&quot;Exception encountered while running foo: &quot;&lt;&lt;e.what()&lt;&lt;std::endl;
        std::cerr&lt;&lt;&quot;Thrown from:&quot;&lt;&lt;std::endl;
        cpptrace::from_current_exception().print(); // trace containing main -&gt; foo -&gt; bar
        std::cerr&lt;&lt;&quot;Rethrown from:&quot;&lt;&lt;std::endl;
        cpptrace::from_current_exception_rethrow().print(); // trace containing main -&gt; foo
    }
}"><pre><span class="pl-k">int</span> <span class="pl-en">main</span>() {
    CPPTRACE_TRY {
        <span class="pl-c1">foo</span>();
    } <span class="pl-c1">CPPTRACE_CATCH</span>(<span class="pl-k">const</span> std::exception&amp; e) {
        std::cerr&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Exception encountered while running foo: <span class="pl-pds">"</span></span>&lt;&lt;e.<span class="pl-c1">what</span>()&lt;&lt;std::endl;
        std::cerr&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Thrown from:<span class="pl-pds">"</span></span>&lt;&lt;std::endl;
        <span class="pl-c1">cpptrace::from_current_exception</span>().<span class="pl-c1">print</span>(); <span class="pl-c"><span class="pl-c">//</span> trace containing main -&gt; foo -&gt; bar</span>
        std::cerr&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Rethrown from:<span class="pl-pds">"</span></span>&lt;&lt;std::endl;
        <span class="pl-c1">cpptrace::from_current_exception_rethrow</span>().<span class="pl-c1">print</span>(); <span class="pl-c"><span class="pl-c">//</span> trace containing main -&gt; foo</span>
    }
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto"><code>cpptrace::try_catch</code></h2><a id="user-content-cpptracetry_catch" class="anchor" aria-label="Permalink: cpptrace::try_catch" href="#cpptracetry_catch"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">As mentioned above, in order to facilitate <code>try</code>/<code>catch</code> blocks with multiple handlers while still being able to perform
the magic necessary to collect stack traces on exceptions, cpptrace provides a <code>cpptrace::try_catch</code> utility that can
take multiple handlers:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="cpptrace::try_catch(
    [&amp;] { // try block
        foo();
    },
    [&amp;] (const std::runtime_error&amp; e) {
        std::cerr&lt;&lt;&quot;Runtime error: &quot;&lt;&lt;e.what()&lt;&lt;std::endl;
        cpptrace::from_current_exception().print();
    },
    [&amp;] (const std::exception&amp; e) {
        std::cerr&lt;&lt;&quot;Exception: &quot;&lt;&lt;e.what()&lt;&lt;std::endl;
        cpptrace::from_current_exception().print();
    },
    [&amp;] () { // serves the same role as `catch(...)`, an any exception handler
        std::cerr&lt;&lt;&quot;Unknown exception occurred: &quot;&lt;&lt;std::endl;
        cpptrace::from_current_exception().print();
    }
);"><pre><span class="pl-en">cpptrace::try_catch</span>(
    [&amp;] { <span class="pl-c"><span class="pl-c">//</span> try block</span>
        <span class="pl-c1">foo</span>();
    },
    [&amp;] (<span class="pl-k">const</span> std::runtime_error&amp; e) {
        std::cerr&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Runtime error: <span class="pl-pds">"</span></span>&lt;&lt;e.<span class="pl-c1">what</span>()&lt;&lt;std::endl;
        <span class="pl-c1">cpptrace::from_current_exception</span>().<span class="pl-c1">print</span>();
    },
    [&amp;] (<span class="pl-k">const</span> std::exception&amp; e) {
        std::cerr&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Exception: <span class="pl-pds">"</span></span>&lt;&lt;e.<span class="pl-c1">what</span>()&lt;&lt;std::endl;
        <span class="pl-c1">cpptrace::from_current_exception</span>().<span class="pl-c1">print</span>();
    },
    [&amp;] () { <span class="pl-c"><span class="pl-c">//</span> serves the same role as `catch(...)`, an any exception handler</span>
        std::cerr&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Unknown exception occurred: <span class="pl-pds">"</span></span>&lt;&lt;std::endl;
        <span class="pl-c1">cpptrace::from_current_exception</span>().<span class="pl-c1">print</span>();
    }
);</pre></div>
<p dir="auto">The synopsis for this utility is:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace cpptrace {
    template&lt;typename F, typename... Catches&gt;
    void try_catch(F&amp;&amp; f, Catches&amp;&amp;... catches);
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">cpptrace</span> {
    <span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> F, <span class="pl-k">typename</span>... Catches&gt;
    <span class="pl-k">void</span> <span class="pl-en">try_catch</span>(F&amp;&amp; f, Catches&amp;&amp;... catches);
}</pre></div>
<p dir="auto">Similar to a language <code>try</code>/<code>catch</code>, <code>catch</code> handlers will be considered in the order they are listed. Handlers should
take exactly one argument, equivalent to what would be written for a catch handler, except for <code>catch(...)</code> which can be
achieved by a handler taking no arguments.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Traces from SEH exceptions</h2><a id="user-content-traces-from-seh-exceptions" class="anchor" aria-label="Permalink: Traces from SEH exceptions" href="#traces-from-seh-exceptions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Similar to the above section on collecting <a href="#traces-from-all-exceptions-cpptrace_try-and-cpptrace_catch">traces from C++ exceptions</a>,
cpptrace provides <code>CPPTRACE_SEH_TRY</code> and <code>CPPTRACE_SEH_EXCEPT</code> macros that collect traces from SEH exceptions on windows
with no overhead in the non-throwing (happy) path:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="#include &lt;cpptrace/from_current.hpp&gt;
#include &lt;iostream&gt;
#include &lt;windows.h&gt;

void foo(int x, int y) {
    return x / y;
}

int divide_zero_filter(int code) {
    if(code == STATUS_INTEGER_DIVIDE_BY_ZERO || code == EXCEPTION_FLT_DIVIDE_BY_ZERO) {
        return EXCEPTION_EXECUTE_HANDLER;
    }
    return EXCEPTION_CONTINUE_SEARCH;
}

int main() {
    CPPTRACE_SEH_TRY {
        foo(10, 0);
    } CPPTRACE_SEH_EXCEPT(divide_zero_filter(GetExceptionCode())) {
        std::cerr&lt;&lt;&quot;Division by zero happened!&quot;&lt;&lt;std::endl;
        cpptrace::from_current_exception().print();
    }
}"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>cpptrace/from_current.hpp<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>windows.h<span class="pl-pds">&gt;</span></span>

<span class="pl-k">void</span> <span class="pl-en">foo</span>(<span class="pl-k">int</span> x, <span class="pl-k">int</span> y) {
    <span class="pl-k">return</span> x / y;
}

<span class="pl-k">int</span> <span class="pl-en">divide_zero_filter</span>(<span class="pl-k">int</span> code) {
    <span class="pl-k">if</span>(code == STATUS_INTEGER_DIVIDE_BY_ZERO || code == EXCEPTION_FLT_DIVIDE_BY_ZERO) {
        <span class="pl-k">return</span> EXCEPTION_EXECUTE_HANDLER;
    }
    <span class="pl-k">return</span> EXCEPTION_CONTINUE_SEARCH;
}

<span class="pl-k">int</span> <span class="pl-en">main</span>() {
    CPPTRACE_SEH_TRY {
        <span class="pl-c1">foo</span>(<span class="pl-c1">10</span>, <span class="pl-c1">0</span>);
    } <span class="pl-c1">CPPTRACE_SEH_EXCEPT</span>(<span class="pl-c1">divide_zero_filter</span>(<span class="pl-c1">GetExceptionCode</span>())) {
        std::cerr&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Division by zero happened!<span class="pl-pds">"</span></span>&lt;&lt;std::endl;
        <span class="pl-c1">cpptrace::from_current_exception</span>().<span class="pl-c1">print</span>();
    }
}</pre></div>
<p dir="auto">The <code>CPPTRACE_SEH_EXCEPT</code> macro takes a filter expression as input, any expression valid in <code>__except</code> is valid.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Traced Exception Objects</h2><a id="user-content-traced-exception-objects" class="anchor" aria-label="Permalink: Traced Exception Objects" href="#traced-exception-objects"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Cpptrace provides a handful of traced exception classes which automatically collect stack traces when thrown. These
are useful when throwing exceptions that may not be caught by <code>CPPTRACE_CATCH</code>.</p>
<p dir="auto">The base traced exception class is <code>cpptrace::exception</code> and cpptrace provides a handful of helper classes for working
with traced exceptions. These exceptions generate relatively lightweight raw traces and resolve symbols and line numbers
lazily if and when requested.</p>
<p dir="auto">These are provided both as a useful utility and as a reference implementation for traced exceptions.</p>
<p dir="auto">The basic interface is:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace cpptrace {
    class exception : public std::exception {
    public:
        virtual const char* what() const noexcept = 0; // The what string both the message and trace
        virtual const char* message() const noexcept = 0;
        virtual const stacktrace&amp; trace() const noexcept = 0;
    };
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">cpptrace</span> {
    <span class="pl-k">class</span> <span class="pl-en">exception</span> : <span class="pl-k">public</span> <span class="pl-en">std</span>::exception {
    <span class="pl-k">public:</span>
        <span class="pl-k">virtual</span> <span class="pl-k">const</span> <span class="pl-k">char</span>* <span class="pl-en">what</span>() <span class="pl-k">const</span> <span class="pl-k">noexcept</span> = 0; <span class="pl-c"><span class="pl-c">//</span> The what string both the message and trace</span>
        <span class="pl-k">virtual</span> <span class="pl-k">const</span> <span class="pl-k">char</span>* <span class="pl-en">message</span>() <span class="pl-k">const</span> <span class="pl-k">noexcept</span> = 0;
        <span class="pl-k">virtual</span> <span class="pl-k">const</span> stacktrace&amp; <span class="pl-en">trace</span>() <span class="pl-k">const</span> <span class="pl-k">noexcept</span> = 0;
    };
}</pre></div>
<p dir="auto">There are two ways to go about traced exception objects: Traces can be resolved eagerly or lazily. Cpptrace provides the
basic implementation of exceptions as lazy exceptions. I hate to have anything about the implementation exposed in the
interface or type system but this seems to be the best way to do this.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace cpptrace {
    class lazy_exception : public exception {
        // lazy_trace_holder is basically a std::variant&lt;raw_trace, stacktrace&gt;, more docs later
        mutable detail::lazy_trace_holder trace_holder;
        mutable std::string what_string;
    public:
        explicit lazy_exception(
            raw_trace&amp;&amp; trace = detail::get_raw_trace_and_absorb()
        ) noexcept : trace_holder(std::move(trace)) {}
        const char* what() const noexcept override;
        const char* message() const noexcept override;
        const stacktrace&amp; trace() const noexcept override;
    };
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">cpptrace</span> {
    <span class="pl-k">class</span> <span class="pl-en">lazy_exception</span> : <span class="pl-k">public</span> <span class="pl-en">exception</span> {
        <span class="pl-c"><span class="pl-c">//</span> lazy_trace_holder is basically a std::variant&lt;raw_trace, stacktrace&gt;, more docs later</span>
        <span class="pl-k">mutable</span> detail::lazy_trace_holder trace_holder;
        <span class="pl-k">mutable</span> std::string what_string;
    <span class="pl-k">public:</span>
        <span class="pl-k">explicit</span> <span class="pl-en">lazy_exception</span>(
            raw_trace&amp;&amp; trace = detail::get_raw_trace_and_absorb()
        ) <span class="pl-k">noexcept</span> : trace_holder(std::move(trace)) {}
        <span class="pl-k">const</span> <span class="pl-k">char</span>* <span class="pl-en">what</span>() <span class="pl-k">const</span> <span class="pl-k">noexcept</span> <span class="pl-k">override</span>;
        <span class="pl-k">const</span> <span class="pl-k">char</span>* <span class="pl-en">message</span>() <span class="pl-k">const</span> <span class="pl-k">noexcept</span> <span class="pl-k">override</span>;
        <span class="pl-k">const</span> stacktrace&amp; <span class="pl-en">trace</span>() <span class="pl-k">const</span> <span class="pl-k">noexcept</span> <span class="pl-k">override</span>;
    };
}</pre></div>
<p dir="auto"><code>cpptrace::lazy_exception</code> can be freely thrown or overridden. Generally <code>message()</code> is the only field to override.</p>
<p dir="auto">Lastly cpptrace provides an exception class that takes a user-provided message, <code>cpptrace::exception_with_message</code>, as
well as a number of traced exception classes resembling <code>&lt;stdexcept&gt;</code>:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace cpptrace {
    class exception_with_message : public lazy_exception {
        mutable std::string user_message;
    public:
        explicit exception_with_message(
            std::string&amp;&amp; message_arg,
            raw_trace&amp;&amp; trace = detail::get_raw_trace_and_absorb()
        ) noexcept : lazy_exception(std::move(trace)), user_message(std::move(message_arg)) {}
        const char* message() const noexcept override;
    };

    // All stdexcept errors have analogs here. All but system_error have the constructor:
    // explicit the_error(
    //     std::string&amp;&amp; message_arg,
    //     raw_trace&amp;&amp; trace = detail::get_raw_trace_and_absorb()
    // ) noexcept
    //     : exception_with_message(std::move(message_arg), std::move(trace)) {}
    class logic_error      : public exception_with_message { ... };
    class domain_error     : public exception_with_message { ... };
    class invalid_argument : public exception_with_message { ... };
    class length_error     : public exception_with_message { ... };
    class out_of_range     : public exception_with_message { ... };
    class runtime_error    : public exception_with_message { ... };
    class range_error      : public exception_with_message { ... };
    class overflow_error   : public exception_with_message { ... };
    class underflow_error  : public exception_with_message { ... };
    class system_error : public runtime_error {
    public:
        explicit system_error(
            int error_code,
            std::string&amp;&amp; message_arg,
            raw_trace&amp;&amp; trace = detail::get_raw_trace_and_absorb()
        ) noexcept;
        const std::error_code&amp; code() const noexcept;
    };
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">cpptrace</span> {
    <span class="pl-k">class</span> <span class="pl-en">exception_with_message</span> : <span class="pl-k">public</span> <span class="pl-en">lazy_exception</span> {
        <span class="pl-k">mutable</span> std::string user_message;
    <span class="pl-k">public:</span>
        <span class="pl-k">explicit</span> <span class="pl-en">exception_with_message</span>(
            std::string&amp;&amp; message_arg,
            raw_trace&amp;&amp; trace = detail::get_raw_trace_and_absorb()
        ) <span class="pl-k">noexcept</span> : lazy_exception(std::move(trace)), user_message(std::move(message_arg)) {}
        <span class="pl-k">const</span> <span class="pl-k">char</span>* <span class="pl-en">message</span>() <span class="pl-k">const</span> <span class="pl-k">noexcept</span> <span class="pl-k">override</span>;
    };

    <span class="pl-c"><span class="pl-c">//</span> All stdexcept errors have analogs here. All but system_error have the constructor:</span>
    <span class="pl-c"><span class="pl-c">//</span> explicit the_error(</span>
    <span class="pl-c"><span class="pl-c">//</span>     std::string&amp;&amp; message_arg,</span>
    <span class="pl-c"><span class="pl-c">//</span>     raw_trace&amp;&amp; trace = detail::get_raw_trace_and_absorb()</span>
    <span class="pl-c"><span class="pl-c">//</span> ) noexcept</span>
    <span class="pl-c"><span class="pl-c">//</span>     : exception_with_message(std::move(message_arg), std::move(trace)) {}</span>
    <span class="pl-k">class</span> <span class="pl-en">logic_error</span>      : <span class="pl-k">public</span> <span class="pl-en">exception_with_message</span> { ... };
    <span class="pl-k">class</span> <span class="pl-en">domain_error</span>     : <span class="pl-k">public</span> <span class="pl-en">exception_with_message</span> { ... };
    <span class="pl-k">class</span> <span class="pl-en">invalid_argument</span> : <span class="pl-k">public</span> <span class="pl-en">exception_with_message</span> { ... };
    <span class="pl-k">class</span> <span class="pl-en">length_error</span>     : <span class="pl-k">public</span> <span class="pl-en">exception_with_message</span> { ... };
    <span class="pl-k">class</span> <span class="pl-en">out_of_range</span>     : <span class="pl-k">public</span> <span class="pl-en">exception_with_message</span> { ... };
    <span class="pl-k">class</span> <span class="pl-en">runtime_error</span>    : <span class="pl-k">public</span> <span class="pl-en">exception_with_message</span> { ... };
    <span class="pl-k">class</span> <span class="pl-en">range_error</span>      : <span class="pl-k">public</span> <span class="pl-en">exception_with_message</span> { ... };
    <span class="pl-k">class</span> <span class="pl-en">overflow_error</span>   : <span class="pl-k">public</span> <span class="pl-en">exception_with_message</span> { ... };
    <span class="pl-k">class</span> <span class="pl-en">underflow_error</span>  : <span class="pl-k">public</span> <span class="pl-en">exception_with_message</span> { ... };
    <span class="pl-k">class</span> <span class="pl-en">system_error</span> : <span class="pl-k">public</span> <span class="pl-en">runtime_error</span> {
    <span class="pl-k">public:</span>
        <span class="pl-k">explicit</span> <span class="pl-en">system_error</span>(
            <span class="pl-k">int</span> error_code,
            std::string&amp;&amp; message_arg,
            raw_trace&amp;&amp; trace = detail::get_raw_trace_and_absorb()
        ) <span class="pl-k">noexcept</span>;
        <span class="pl-k">const</span> std::error_code&amp; <span class="pl-en">code</span>() <span class="pl-k">const</span> <span class="pl-k">noexcept</span>;
    };
}</pre></div>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">Wrapping std::exceptions</h3><a id="user-content-wrapping-stdexceptions" class="anchor" aria-label="Permalink: Wrapping std::exceptions" href="#wrapping-stdexceptions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div class="markdown-alert markdown-alert-note" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p dir="auto">This section is largely obsolete now that cpptrace provides a better mechanism for collecting
<a href="#traces-from-exceptions">traces from exceptions</a></p>
</div>
<p dir="auto">Cpptrace exceptions can provide great information for user-controlled exceptions. For non-cpptrace::exceptions that may
originate outside of code you control, e.g. the standard library, cpptrace provides some wrapper utilities that can
rethrow these exceptions nested in traced cpptrace exceptions. The trace won't be perfect, the trace will start where
the wrapper caught it, but these utilities can provide good diagnostic information. Unfortunately this is the best
solution for this problem, as far as I know.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="std::vector&lt;int&gt; foo = {1, 2, 3};
CPPTRACE_WRAP_BLOCK(
    foo.at(4) = 2;
    foo.at(5)++;
);
std::cout&lt;&lt;CPPTRACE_WRAP(foo.at(12))&lt;&lt;std::endl;"><pre>std::vector&lt;<span class="pl-k">int</span>&gt; foo = {<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>};
<span class="pl-en">CPPTRACE_WRAP_BLOCK</span>(
    foo.at(<span class="pl-c1">4</span>) = 2;
    foo.at(<span class="pl-c1">5</span>)++;
);
std::cout&lt;&lt;CPPTRACE_WRAP(foo.at(<span class="pl-c1">12</span>))&lt;&lt;std::endl;</pre></div>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">Exception handling with cpptrace exception objects</h3><a id="user-content-exception-handling-with-cpptrace-exception-objects" class="anchor" aria-label="Permalink: Exception handling with cpptrace exception objects" href="#exception-handling-with-cpptrace-exception-objects"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div class="markdown-alert markdown-alert-note" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p dir="auto">This section pertains to cpptrace traced exception objects and not the mechanism for collecting
<a href="#traces-from-exceptions">traces from arbitrary exceptions</a></p>
</div>
<p dir="auto">Working with cpptrace exceptions in your code:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="try {
    foo();
} catch(cpptrace::exception&amp; e) {
    // Prints the exception info and stack trace, conditionally enabling color codes depending on
    // whether stderr is a terminal
    std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.message() &lt;&lt; '\n';
    e.trace().print(std::cerr, cpptrace::isatty(cpptrace::stderr_fileno));
} catch(std::exception&amp; e) {
    std::cerr &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; '\n';
}"><pre><span class="pl-k">try</span> {
    <span class="pl-c1">foo</span>();
} <span class="pl-k">catch</span>(cpptrace::exception&amp; e) {
    <span class="pl-c"><span class="pl-c">//</span> Prints the exception info and stack trace, conditionally enabling color codes depending on</span>
    <span class="pl-c"><span class="pl-c">//</span> whether stderr is a terminal</span>
    std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Error: <span class="pl-pds">"</span></span> &lt;&lt; e.<span class="pl-c1">message</span>() &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
    e.<span class="pl-c1">trace</span>().<span class="pl-c1">print</span>(std::cerr, <span class="pl-c1">cpptrace::isatty</span>(cpptrace::stderr_fileno));
} <span class="pl-k">catch</span>(std::exception&amp; e) {
    std::cerr &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Error: <span class="pl-pds">"</span></span> &lt;&lt; e.<span class="pl-c1">what</span>() &lt;&lt; <span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>;
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Terminate Handling</h2><a id="user-content-terminate-handling" class="anchor" aria-label="Permalink: Terminate Handling" href="#terminate-handling"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Cpptrace provides a custom <code>std::terminate</code> handler that prints stacktraces while otherwise behaving like the normal
<code>std::terminate</code> handler. If a cpptrace exception object reaches <code>std::terminate</code> the trace from that exception is
printed, otherwise a stack trace is generated at the point of the terminate handler. Often <code>std::terminate</code> is called
directly without unwinding so the trace is preserved.</p>
<p dir="auto">To register this custom handler:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="cpptrace::register_terminate_handler();"><pre><span class="pl-en">cpptrace::register_terminate_handler</span>();</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Signal-Safe Tracing</h2><a id="user-content-signal-safe-tracing" class="anchor" aria-label="Permalink: Signal-Safe Tracing" href="#signal-safe-tracing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Stack traces from signal handlers can provide very helpful information for debugging application crashes, e.g. from
SIGSEGV or SIGTRAP handlers. Signal handlers are really restrictive environments as your application could be
interrupted by a signal at any point, including in the middle of malloc or buffered IO or while holding a lock.
Doing a stack trace in a signal handler is possible but it requires a lot of care. This is difficult to do correctly
and most examples online do this incorrectly.</p>
<p dir="auto">Cpptrace offers an API to walk the stack in a signal handler and produce a raw trace safely. The library also provides
an interface for producing a object frame safely:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace cpptrace {
    std::size_t safe_generate_raw_trace(frame_ptr* buffer, std::size_t size, std::size_t skip = 0);
    std::size_t safe_generate_raw_trace(frame_ptr* buffer, std::size_t size, std::size_t skip, std::size_t max_depth);
    struct safe_object_frame {
        frame_ptr raw_address;
        frame_ptr address_relative_to_object_start;
        char object_path[CPPTRACE_PATH_MAX + 1];
        object_frame resolve() const; // To be called outside a signal handler. Not signal safe.
    };
    void get_safe_object_frame(frame_ptr address, safe_object_frame* out);
    bool can_signal_safe_unwind();
    bool can_get_safe_object_frame();
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">cpptrace</span> {
    std::<span class="pl-c1">size_t</span> <span class="pl-en">safe_generate_raw_trace</span>(frame_ptr* buffer, std::<span class="pl-c1">size_t</span> size, std::<span class="pl-c1">size_t</span> skip = <span class="pl-c1">0</span>);
    std::<span class="pl-c1">size_t</span> <span class="pl-en">safe_generate_raw_trace</span>(frame_ptr* buffer, std::<span class="pl-c1">size_t</span> size, std::<span class="pl-c1">size_t</span> skip, std::<span class="pl-c1">size_t</span> max_depth);
    <span class="pl-k">struct</span> <span class="pl-en">safe_object_frame</span> {
        frame_ptr raw_address;
        frame_ptr address_relative_to_object_start;
        <span class="pl-k">char</span> object_path[CPPTRACE_PATH_MAX + <span class="pl-c1">1</span>];
        object_frame <span class="pl-en">resolve</span>() <span class="pl-k">const</span>; <span class="pl-c"><span class="pl-c">//</span> To be called outside a signal handler. Not signal safe.</span>
    };
    <span class="pl-k">void</span> <span class="pl-en">get_safe_object_frame</span>(frame_ptr address, safe_object_frame* out);
    <span class="pl-k">bool</span> <span class="pl-en">can_signal_safe_unwind</span>();
    <span class="pl-k">bool</span> <span class="pl-en">can_get_safe_object_frame</span>();
}</pre></div>
<p dir="auto">It is not possible to resolve debug symbols safely in the process from a signal handler without heroic effort. In order
to produce a full trace there are three options:</p>
<ol dir="auto">
<li>Carefully save the object trace information to be resolved at a later time outside the signal handler</li>
<li>Write the object trace information to a file to be resolved later</li>
<li>Spawn a new process, communicate object trace information to that process, and have that process do the trace
resolution</li>
</ol>
<p dir="auto">For traces on segfaults, e.g., only options 2 and 3 are viable. For more information an implementation of approach 3,
see the comprehensive overview and demo at <a href="docs/signal-safe-tracing.md">signal-safe-tracing.md</a>.</p>
<div class="markdown-alert markdown-alert-important" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-report mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p><p dir="auto">Currently signal-safe stack unwinding is only possible with <code>libunwind</code>, which must be
<a href="#library-back-ends">manually enabled</a>. If signal-safe unwinding isn't supported, <code>safe_generate_raw_trace</code> will just
produce an empty trace. <code>can_signal_safe_unwind</code> can be used to check for signal-safe unwinding support and
<code>can_get_safe_object_frame</code> can be used to check <code>get_safe_object_frame</code> support. If object information can't be
resolved in a signal-safe way then <code>get_safe_object_frame</code> will not populate fields beyond the <code>raw_address</code>.</p>
</div>
<div class="markdown-alert markdown-alert-important" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-report mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p><p dir="auto"><code>_dl_find_object</code> is required for signal-safe stack tracing. This is a relatively recent addition to glibc, added in
glibc 2.35.</p>
</div>
<div class="markdown-alert markdown-alert-caution" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-stop mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M4.47.22A.749.749 0 0 1 5 0h6c.199 0 .389.079.53.22l4.25 4.25c.141.14.22.331.22.53v6a.749.749 0 0 1-.22.53l-4.25 4.25A.749.749 0 0 1 11 16H5a.749.749 0 0 1-.53-.22L.22 11.53A.749.749 0 0 1 0 11V5c0-.199.079-.389.22-.53Zm.84 1.28L1.5 5.31v5.38l3.81 3.81h5.38l3.81-3.81V5.31L10.69 1.5ZM8 4a.75.75 0 0 1 .75.75v3.5a.75.75 0 0 1-1.5 0v-3.5A.75.75 0 0 1 8 4Zm0 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Caution</p><p dir="auto">Calls to shared objects can be lazy-loaded where the first call to the shared object invokes non-signal-safe functions
such as <code>malloc()</code>. To avoid this, call these routines in <code>main()</code> ahead of a signal handler to "warm up" the library.</p>
</div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Utility Types</h2><a id="user-content-utility-types" class="anchor" aria-label="Permalink: Utility Types" href="#utility-types"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">A couple utility types are used to provide the library with a good interface.</p>
<p dir="auto"><code>nullable&lt;T&gt;</code> is used for a nullable integer type. Internally the maximum value for <code>T</code> is used as a
sentinel. <code>std::optional</code> would be used if this library weren't c++11. But, <code>nullable&lt;T&gt;</code> provides
an <code>std::optional</code>-like interface and it's less heavy-duty for this use than an <code>std::optional</code>.</p>
<p dir="auto"><code>detail::lazy_trace_holder</code> is a utility type for <code>lazy_exception</code> used in place of an
<code>std::variant&lt;raw_trace, stacktrace&gt;</code>.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace cpptrace {
    template&lt;typename T, typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, int&gt;::type = 0&gt;
    struct nullable {
        T raw_value;
        // all members are constexpr for c++17 and beyond, some are constexpr before c++17
        nullable&amp; operator=(T value)
        bool has_value() const noexcept;
        T&amp; value() noexcept;
        const T&amp; value() const noexcept;
        T value_or(T alternative) const noexcept;
        void swap(nullable&amp; other) noexcept;
        void reset() noexcept;
        bool operator==(const nullable&amp; other) const noexcept;
        bool operator!=(const nullable&amp; other) const noexcept;
        constexpr static T null_value() noexcept; // returns the raw null value
        constexpr static nullable null() noexcept; // returns a null instance
    };

    namespace detail {
        class lazy_trace_holder {
            bool resolved;
            union {
                raw_trace trace;
                stacktrace resolved_trace;
            };
        public:
            // constructors
            lazy_trace_holder() : trace() {}
            explicit lazy_trace_holder(raw_trace&amp;&amp; _trace);
            explicit lazy_trace_holder(stacktrace&amp;&amp; _resolved_trace);
            // logistics
            lazy_trace_holder(const lazy_trace_holder&amp; other);
            lazy_trace_holder(lazy_trace_holder&amp;&amp; other) noexcept;
            lazy_trace_holder&amp; operator=(const lazy_trace_holder&amp; other);
            lazy_trace_holder&amp; operator=(lazy_trace_holder&amp;&amp; other) noexcept;
            ~lazy_trace_holder();
            // access
            const raw_trace&amp; get_raw_trace() const;
            stacktrace&amp; get_resolved_trace();
            const stacktrace&amp; get_resolved_trace() const; // throws if not already resolved
            bool is_resolved() const;
        private:
            void clear();
        };
    }
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">cpptrace</span> {
    <span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T, <span class="pl-k">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, <span class="pl-k">int</span>&gt;::type = <span class="pl-c1">0</span>&gt;
    <span class="pl-k">struct</span> <span class="pl-en">nullable</span> {
        T raw_value;
        <span class="pl-c"><span class="pl-c">//</span> all members are constexpr for c++17 and beyond, some are constexpr before c++17</span>
        nullable&amp; <span class="pl-k">operator</span>=(T value)
        <span class="pl-k">bool</span> <span class="pl-en">has_value</span>() <span class="pl-k">const</span> <span class="pl-k">noexcept</span>;
        T&amp; <span class="pl-en">value</span>() <span class="pl-k">noexcept</span>;
        <span class="pl-k">const</span> T&amp; <span class="pl-en">value</span>() <span class="pl-k">const</span> <span class="pl-k">noexcept</span>;
        T <span class="pl-en">value_or</span>(T alternative) <span class="pl-k">const</span> <span class="pl-k">noexcept</span>;
        <span class="pl-k">void</span> <span class="pl-en">swap</span>(nullable&amp; other) <span class="pl-k">noexcept</span>;
        <span class="pl-k">void</span> <span class="pl-en">reset</span>() <span class="pl-k">noexcept</span>;
        <span class="pl-k">bool</span> <span class="pl-k">operator</span>==(<span class="pl-k">const</span> nullable&amp; other) <span class="pl-k">const</span> <span class="pl-k">noexcept</span>;
        <span class="pl-k">bool</span> <span class="pl-k">operator</span>!=(<span class="pl-k">const</span> nullable&amp; other) <span class="pl-k">const</span> <span class="pl-k">noexcept</span>;
        <span class="pl-k">constexpr</span> <span class="pl-k">static</span> T <span class="pl-en">null_value</span>() <span class="pl-k">noexcept</span>; <span class="pl-c"><span class="pl-c">//</span> returns the raw null value</span>
        <span class="pl-k">constexpr</span> <span class="pl-k">static</span> nullable <span class="pl-en">null</span>() <span class="pl-k">noexcept</span>; <span class="pl-c"><span class="pl-c">//</span> returns a null instance</span>
    };

    <span class="pl-k">namespace</span> <span class="pl-en">detail</span> {
        <span class="pl-k">class</span> <span class="pl-en">lazy_trace_holder</span> {
            <span class="pl-k">bool</span> resolved;
            <span class="pl-k">union</span> {
                raw_trace trace;
                stacktrace resolved_trace;
            };
        <span class="pl-k">public:</span>
            <span class="pl-c"><span class="pl-c">//</span> constructors</span>
            <span class="pl-en">lazy_trace_holder</span>() : trace() {}
            <span class="pl-k">explicit</span> <span class="pl-en">lazy_trace_holder</span>(raw_trace&amp;&amp; _trace);
            <span class="pl-k">explicit</span> <span class="pl-en">lazy_trace_holder</span>(stacktrace&amp;&amp; _resolved_trace);
            <span class="pl-c"><span class="pl-c">//</span> logistics</span>
            <span class="pl-en">lazy_trace_holder</span>(<span class="pl-k">const</span> lazy_trace_holder&amp; other);
            <span class="pl-en">lazy_trace_holder</span>(lazy_trace_holder&amp;&amp; other) <span class="pl-k">noexcept</span>;
            lazy_trace_holder&amp; <span class="pl-k">operator</span>=(<span class="pl-k">const</span> lazy_trace_holder&amp; other);
            lazy_trace_holder&amp; <span class="pl-k">operator</span>=(lazy_trace_holder&amp;&amp; other) <span class="pl-k">noexcept</span>;
            <span class="pl-en">~lazy_trace_holder</span>();
            <span class="pl-c"><span class="pl-c">//</span> access</span>
            <span class="pl-k">const</span> raw_trace&amp; <span class="pl-en">get_raw_trace</span>() <span class="pl-k">const</span>;
            stacktrace&amp; <span class="pl-en">get_resolved_trace</span>();
            <span class="pl-k">const</span> stacktrace&amp; <span class="pl-en">get_resolved_trace</span>() <span class="pl-k">const</span>; <span class="pl-c"><span class="pl-c">//</span> throws if not already resolved</span>
            <span class="pl-k">bool</span> <span class="pl-en">is_resolved</span>() <span class="pl-k">const</span>;
        <span class="pl-k">private:</span>
            <span class="pl-k">void</span> <span class="pl-en">clear</span>();
        };
    }
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Headers</h2><a id="user-content-headers" class="anchor" aria-label="Permalink: Headers" href="#headers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Cpptrace provides a handful of headers to make inclusion more minimal.</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Header</th>
<th>Contents</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cpptrace/forward.hpp</code></td>
<td><code>cpptrace::frame_ptr</code> and a few trace class forward declarations</td>
</tr>
<tr>
<td><code>cpptrace/basic.hpp</code></td>
<td>Definitions for trace classes and the basic tracing APIs (<a href="#stack-traces">Stack Traces</a>, <a href="#object-traces">Object Traces</a>, <a href="#raw-traces">Raw Traces</a>, and <a href="#signal-safe-tracing">Signal-Safe Tracing</a>)</td>
</tr>
<tr>
<td><code>cpptrace/exceptions.hpp</code></td>
<td><a href="#traced-exception-objects">Traced Exception Objects</a> and related utilities (<a href="#wrapping-stdexceptions">Wrapping std::exceptions</a>)</td>
</tr>
<tr>
<td><code>cpptrace/from_current.hpp</code></td>
<td><a href="#traces-from-all-exceptions">Traces From All Exceptions</a></td>
</tr>
<tr>
<td><code>cpptrace/io.hpp</code></td>
<td><code>operator&lt;&lt;</code> overloads for <code>std::ostream</code> and <code>std::formatter</code>s</td>
</tr>
<tr>
<td><code>cpptrace/formatting.hpp</code></td>
<td>Configurable formatter API</td>
</tr>
<tr>
<td><code>cpptrace/utils.hpp</code></td>
<td>Utility functions, configuration functions, and terminate utilities (<a href="#utilities">Utilities</a>, <a href="#configuration">Configuration</a>, and <a href="#terminate-handling">Terminate Handling</a>)</td>
</tr>
<tr>
<td><code>cpptrace/version.hpp</code></td>
<td>Library version macros</td>
</tr>
<tr>
<td><code>cpptrace/gdb_jit.hpp</code></td>
<td>Provides a special utility related to <a href="#jit-support">JIT support</a></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">The main cpptrace header is <code>cpptrace/cpptrace.hpp</code> which includes everything other than <code>from_current.hpp</code> and
<code>version.hpp</code>.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Libdwarf Tuning</h2><a id="user-content-libdwarf-tuning" class="anchor" aria-label="Permalink: Libdwarf Tuning" href="#libdwarf-tuning"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">For extraordinarily large binaries (multiple gigabytes), cpptrace's internal caching can result in a lot of memory
usage. Cpptrace provides some options to reduce memory usage in exchange for performance in memory-constrained
applications.</p>
<p dir="auto">Synopsis:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace cpptrace {
    namespace experimental {
        void set_dwarf_resolver_line_table_cache_size(nullable&lt;std::size_t&gt; max_entries);
        void set_dwarf_resolver_disable_aranges(bool disable);
    }
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">cpptrace</span> {
    <span class="pl-k">namespace</span> <span class="pl-en">experimental</span> {
        <span class="pl-k">void</span> <span class="pl-en">set_dwarf_resolver_line_table_cache_size</span>(nullable&lt;std::<span class="pl-c1">size_t</span>&gt; max_entries);
        <span class="pl-k">void</span> <span class="pl-en">set_dwarf_resolver_disable_aranges</span>(<span class="pl-k">bool</span> disable);
    }
}</pre></div>
<p dir="auto">Explanation:</p>
<ul dir="auto">
<li><code>set_dwarf_resolver_line_table_cache_size</code> can be used to set a limit to the cache size with evictions done LRU.
Cpptrace loads and caches line tables for dwarf compile units. These can take a lot of space for large binaries with
lots of debug info. Passing <code>nullable&lt;std::size_t&gt;::null()</code> will disable the cache size (which is the default
behavior).</li>
<li><code>set_dwarf_resolver_disable_aranges</code> can be used to disable use of dwarf <code>.debug_aranges</code>, an accelerated range lookup
table for compile units emitted by many compilers. Cpptrace uses these by default if they are present since they can
speed up resolution, however, they can also result in significant memory usage.</li>
</ul>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">JIT Support</h2><a id="user-content-jit-support" class="anchor" aria-label="Permalink: JIT Support" href="#jit-support"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Cpptrace has support for resolving symbols from frames in JIT-compiled code. To do this, cpptrace relies on in-memory
object files (elf on linux or mach-o on mac) that contain symbol tables and dwarf debug information. The main reason for
this is many JIT implementations already produce these for debugger support.</p>
<p dir="auto">These in-memory object files must be set up in such a way that the symbol table and debug symbol addresses match the
run-time addresses of the JIT code.</p>
<p dir="auto">The basic interface for informing cpptrace about these in-memory object files is as follows:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace cpptrace {
    void register_jit_object(const char*, std::size_t);
    void unregister_jit_object(const char*);
    void clear_all_jit_objects();
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">cpptrace</span> {
    <span class="pl-k">void</span> <span class="pl-en">register_jit_object</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*, std::<span class="pl-c1">size_t</span>);
    <span class="pl-k">void</span> <span class="pl-en">unregister_jit_object</span>(<span class="pl-k">const</span> <span class="pl-k">char</span>*);
    <span class="pl-k">void</span> <span class="pl-en">clear_all_jit_objects</span>();
}</pre></div>
<p dir="auto">Many JIT implementations follow the GDB <a href="https://sourceware.org/gdb/current/onlinedocs/gdb.html/JIT-Interface.html" rel="nofollow">JIT Compilation Interface</a> so that JIT code can be debugged. The
interface, at a high level, entails adding in-memory object files to a linked list of object files that GDB and other
debuggers can reference (stored in the <code>__jit_debug_descriptor</code>). Cpptrace provides, as a utility, a mechanism for
loading all in-memory object files present in the <code>__jit_debug_descriptor</code> linked list via <code>&lt;cpptrace/gdb_jit.hpp&gt;</code>:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace cpptrace {
    namespace experimental {
        void register_jit_objects_from_gdb_jit_interface();
    }
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">cpptrace</span> {
    <span class="pl-k">namespace</span> <span class="pl-en">experimental</span> {
        <span class="pl-k">void</span> <span class="pl-en">register_jit_objects_from_gdb_jit_interface</span>();
    }
}</pre></div>
<p dir="auto">Note: Your program must be able to link against a global C symbol <code>__jit_debug_descriptor</code>.</p>
<p dir="auto">Note: Calling <code>cpptrace::experimental::register_jit_objects_from_gdb_jit_interface</code> clears all jit objects previously
registered with cpptrace.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Loading Libraries at Runtime</h2><a id="user-content-loading-libraries-at-runtime" class="anchor" aria-label="Permalink: Loading Libraries at Runtime" href="#loading-libraries-at-runtime"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This section only applies to the dbghelp backend (<code>CPPTRACE_GET_SYMBOLS_WITH_DBGHELP</code>) on Windows.</p>
<p dir="auto">When loading a DLL at runtime with <code>LoadLibrary</code> after a stacktrace has already been generated,
symbols from that library may not be resolved correctly for subsequent stacktraces. To fix this,
call <code>cpptrace::load_symbols_for_file</code> with the same path that was passed to <code>LoadLibrary</code>.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="HMODULE hModule = LoadLibrary(&quot;mydll.dll&quot;);
if (hModule) {
    cpptrace::load_symbols_for_file(&quot;mydll.dll&quot;);
}"><pre>HMODULE hModule = LoadLibrary(<span class="pl-s"><span class="pl-pds">"</span>mydll.dll<span class="pl-pds">"</span></span>);
<span class="pl-k">if</span> (hModule) {
    <span class="pl-c1">cpptrace::load_symbols_for_file</span>(<span class="pl-s"><span class="pl-pds">"</span>mydll.dll<span class="pl-pds">"</span></span>);
}</pre></div>
<p dir="auto">For backends other than dbghelp, <code>load_symbols_for_file</code> does nothing. For platforms other than
Windows, it is not declared.</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="namespace cpptrace {
    void load_symbols_for_file(const std::string&amp; filename);
}"><pre><span class="pl-k">namespace</span> <span class="pl-en">cpptrace</span> {
    <span class="pl-k">void</span> <span class="pl-en">load_symbols_for_file</span>(<span class="pl-k">const</span> std::string&amp; filename);
}</pre></div>
<div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">ABI Versioning</h1><a id="user-content-abi-versioning" class="anchor" aria-label="Permalink: ABI Versioning" href="#abi-versioning"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Since cpptrace v1.0.0, the library uses an inline ABI versioning namespace and all symbols part of the public interface
are secretly under the namespace <code>cpptrace::v1</code>. This is done to allow for potential future library evolution in an
ABI-friendly manner.</p>
<div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">Supported Debug Formats</h1><a id="user-content-supported-debug-formats" class="anchor" aria-label="Permalink: Supported Debug Formats" href="#supported-debug-formats"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Format</th>
<th>Supported</th>
</tr>
</thead>
<tbody>
<tr>
<td>DWARF in binary</td>
<td></td>
</tr>
<tr>
<td>GNU debug link</td>
<td></td>
</tr>
<tr>
<td>Split dwarf (debug fission)</td>
<td></td>
</tr>
<tr>
<td>DWARF in dSYM</td>
<td></td>
</tr>
<tr>
<td>DWARF via Mach-O debug map</td>
<td></td>
</tr>
<tr>
<td>Windows debug symbols in PDB</td>
<td></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">DWARF5 added DWARF package files. As far as I can tell no compiler implements these yet.</p>
<div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">How to Include The Library</h1><a id="user-content-how-to-include-the-library" class="anchor" aria-label="Permalink: How to Include The Library" href="#how-to-include-the-library"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">CMake FetchContent</h2><a id="user-content-cmake-fetchcontent" class="anchor" aria-label="Permalink: CMake FetchContent" href="#cmake-fetchcontent"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">With CMake FetchContent:</p>
<div class="highlight highlight-source-cmake notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="include(FetchContent)
FetchContent_Declare(
  cpptrace
  GIT_REPOSITORY https://github.com/jeremy-rifkin/cpptrace.git
  GIT_TAG        v1.0.4 # &lt;HASH or TAG&gt;
)
FetchContent_MakeAvailable(cpptrace)
target_link_libraries(your_target cpptrace::cpptrace)"><pre><span class="pl-k">include</span>(FetchContent)
FetchContent_Declare(
  cpptrace
  GIT_REPOSITORY https://github.com/jeremy-rifkin/cpptrace.git
  GIT_TAG        v1.0.4 <span class="pl-c"># &lt;HASH or TAG&gt;</span>
)
FetchContent_MakeAvailable(cpptrace)
<span class="pl-k">target_link_libraries</span>(your_target cpptrace::cpptrace)</pre></div>
<p dir="auto">It's as easy as that. Cpptrace will automatically configure itself for your system. Note: On windows and macos some
extra work is required, see <a href="#platform-logistics">Platform Logistics</a> below.</p>
<p dir="auto">Be sure to configure with <code>-DCMAKE_BUILD_TYPE=Debug</code> or <code>-DCMAKE_BUILD_TYPE=RelWithDebInfo</code> for symbols and line
information.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">System-Wide Installation</h2><a id="user-content-system-wide-installation" class="anchor" aria-label="Permalink: System-Wide Installation" href="#system-wide-installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="git clone https://github.com/jeremy-rifkin/cpptrace.git
git checkout v1.0.4
mkdir cpptrace/build
cd cpptrace/build
cmake .. -DCMAKE_BUILD_TYPE=Release
make -j
sudo make install"><pre>git clone https://github.com/jeremy-rifkin/cpptrace.git
git checkout v1.0.4
mkdir cpptrace/build
<span class="pl-c1">cd</span> cpptrace/build
cmake .. -DCMAKE_BUILD_TYPE=Release
make -j
sudo make install</pre></div>
<p dir="auto">Using through cmake:</p>
<div class="highlight highlight-source-cmake notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="find_package(cpptrace REQUIRED)
target_link_libraries(&lt;your target&gt; cpptrace::cpptrace)"><pre><span class="pl-k">find_package</span>(cpptrace REQUIRED)
<span class="pl-k">target_link_libraries</span>(&lt;your <span class="pl-k">target</span>&gt; cpptrace::cpptrace)</pre></div>
<p dir="auto">Be sure to configure with <code>-DCMAKE_BUILD_TYPE=Debug</code> or <code>-DCMAKE_BUILD_TYPE=RelWithDebInfo</code> for symbols and line
information.</p>
<p dir="auto">Or compile with <code>-lcpptrace</code>:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="g++ main.cpp -o main -g -Wall -lcpptrace
./main"><pre>g++ main.cpp -o main -g -Wall -lcpptrace
./main</pre></div>
<div class="markdown-alert markdown-alert-important" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-report mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p><p dir="auto">If you aren't using cmake and are linking statically you must manually specify <code>-DCPPTRACE_STATIC_DEFINE</code>.</p>
</div>
<p dir="auto">If you get an error along the lines of</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="error while loading shared libraries: libcpptrace.so: cannot open shared object file: No such file or directory"><pre class="notranslate"><code>error while loading shared libraries: libcpptrace.so: cannot open shared object file: No such file or directory
</code></pre></div>
<p dir="auto">You may have to run <code>sudo /sbin/ldconfig</code> to create any necessary links and update caches so the system can find
libcpptrace.so (I had to do this on Ubuntu). Only when installing system-wide. Usually your package manager does this for
you when installing new libraries.</p>
<div class="markdown-alert markdown-alert-note" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-info mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p><p dir="auto">Libdwarf requires a relatively new version of libdwarf. Sometimes a previously-installed system-wide libdwarf may
cause issues due to being too old. Libdwarf 8 and newer is known to work.</p>
</div>
<details>
    <summary>System-wide install on windows</summary>
<div class="highlight highlight-source-powershell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="git clone https://github.com/jeremy-rifkin/cpptrace.git
git checkout v1.0.4
mkdir cpptrace/build
cd cpptrace/build
cmake .. -DCMAKE_BUILD_TYPE=Release
msbuild cpptrace.sln
msbuild INSTALL.vcxproj"><pre>git clone https:<span class="pl-k">//</span><span class="pl-c1">github.com</span><span class="pl-k">/</span>jeremy<span class="pl-k">-</span>rifkin<span class="pl-k">/</span>cpptrace.git
git checkout v1.<span class="pl-c1">0.4</span>
mkdir cpptrace<span class="pl-k">/</span>build
cd cpptrace<span class="pl-k">/</span>build
cmake .<span class="pl-k">.</span> <span class="pl-k">-</span>DCMAKE_BUILD_TYPE<span class="pl-k">=</span>Release
msbuild cpptrace.sln
msbuild INSTALL.vcxproj</pre></div>
<p dir="auto">Note: You'll need to run as an administrator in a developer powershell, or use vcvarsall.bat distributed with visual
studio to get the correct environment variables set.</p>
</details>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Local User Installation</h2><a id="user-content-local-user-installation" class="anchor" aria-label="Permalink: Local User Installation" href="#local-user-installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">To install just for the local user (or any custom prefix):</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="git clone https://github.com/jeremy-rifkin/cpptrace.git
git checkout v1.0.4
mkdir cpptrace/build
cd cpptrace/build
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=$HOME/wherever
make -j
make install"><pre>git clone https://github.com/jeremy-rifkin/cpptrace.git
git checkout v1.0.4
mkdir cpptrace/build
<span class="pl-c1">cd</span> cpptrace/build
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=<span class="pl-smi">$HOME</span>/wherever
make -j
make install</pre></div>
<p dir="auto">Using through cmake:</p>
<div class="highlight highlight-source-cmake notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="find_package(cpptrace REQUIRED PATHS $ENV{HOME}/wherever)
target_link_libraries(&lt;your target&gt; cpptrace::cpptrace)"><pre><span class="pl-k">find_package</span>(cpptrace REQUIRED <span class="pl-k">PATHS</span> <span class="pl-k">$ENV{HOME}</span>/wherever)
<span class="pl-k">target_link_libraries</span>(&lt;your <span class="pl-k">target</span>&gt; cpptrace::cpptrace)</pre></div>
<p dir="auto">Using manually:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="g++ main.cpp -o main -g -Wall -I$HOME/wherever/include -L$HOME/wherever/lib -lcpptrace"><pre class="notranslate"><code>g++ main.cpp -o main -g -Wall -I$HOME/wherever/include -L$HOME/wherever/lib -lcpptrace
</code></pre></div>
<div class="markdown-alert markdown-alert-important" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-report mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p><p dir="auto">If you aren't using cmake and are linking statically you must manually specify <code>-DCPPTRACE_STATIC_DEFINE</code>.</p>
</div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Use Without CMake</h2><a id="user-content-use-without-cmake" class="anchor" aria-label="Permalink: Use Without CMake" href="#use-without-cmake"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">To use the library without cmake first follow the installation instructions at
<a href="#system-wide-installation">System-Wide Installation</a>, <a href="#local-user-installation">Local User Installation</a>,
or <a href="#package-managers">Package Managers</a>.</p>
<p dir="auto">In addition to any include or library paths you'll need to specify to tell the compiler where cpptrace was installed.
The typical dependencies for cpptrace are:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Compiler</th>
<th>Platform</th>
<th>Dependencies</th>
</tr>
</thead>
<tbody>
<tr>
<td>gcc, clang, intel, etc.</td>
<td>Linux/macos/unix</td>
<td><code>-lcpptrace -ldwarf -lz -lzstd -ldl</code></td>
</tr>
<tr>
<td>gcc</td>
<td>Windows</td>
<td><code>-lcpptrace -ldbghelp -ldwarf -lz -lzstd</code></td>
</tr>
<tr>
<td>msvc</td>
<td>Windows</td>
<td><code>cpptrace.lib dbghelp.lib</code></td>
</tr>
<tr>
<td>clang</td>
<td>Windows</td>
<td><code>-lcpptrace -ldbghelp</code></td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">Note: Newer libdwarf requires <code>-lzstd</code>, older libdwarf does not.</p>
<div class="markdown-alert markdown-alert-important" dir="auto"><p class="markdown-alert-title" dir="auto"><svg class="octicon octicon-report mr-2" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M0 1.75C0 .784.784 0 1.75 0h12.5C15.216 0 16 .784 16 1.75v9.5A1.75 1.75 0 0 1 14.25 13H8.06l-2.573 2.573A1.458 1.458 0 0 1 3 14.543V13H1.75A1.75 1.75 0 0 1 0 11.25Zm1.75-.25a.25.25 0 0 0-.25.25v9.5c0 .138.112.25.25.25h2a.75.75 0 0 1 .75.75v2.19l2.72-2.72a.749.749 0 0 1 .53-.22h6.5a.25.25 0 0 0 .25-.25v-9.5a.25.25 0 0 0-.25-.25Zm7 2.25v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 9a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Important</p><p dir="auto">If you are linking statically, you will additionally need to specify <code>-DCPPTRACE_STATIC_DEFINE</code>.</p>
</div>
<p dir="auto">Dependencies may differ if different back-ends are manually selected.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Installation Without Package Managers or FetchContent</h2><a id="user-content-installation-without-package-managers-or-fetchcontent" class="anchor" aria-label="Permalink: Installation Without Package Managers or FetchContent" href="#installation-without-package-managers-or-fetchcontent"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Some users may prefer, or need to, to install cpptrace without package managers or fetchcontent (e.g. if their system
does not have internet access). Below are instructions for how to install libdwarf and cpptrace.</p>
<details>
    <summary>Installation Without Package Managers or FetchContent</summary>
<p dir="auto">Here is an example for how to build cpptrace and libdwarf. <code>~/scratch/cpptrace-test</code> is used as a working directory and
the libraries are installed to <code>~/scratch/cpptrace-test/resources</code>.</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="mkdir -p ~/scratch/cpptrace-test/resources

cd ~/scratch/cpptrace-test
git clone https://github.com/facebook/zstd.git
cd zstd
git checkout 63779c798237346c2b245c546c40b72a5a5913fe
cd build/cmake
mkdir build
cd build
cmake .. -DCMAKE_INSTALL_PREFIX=~/scratch/cpptrace-test/resources -DZSTD_BUILD_PROGRAMS=On -DZSTD_BUILD_CONTRIB=On -DZSTD_BUILD_TESTS=On -DZSTD_BUILD_STATIC=On -DZSTD_BUILD_SHARED=On -DZSTD_LEGACY_SUPPORT=On
make -j
make install

cd ~/scratch/cpptrace-test
git clone https://github.com/jeremy-rifkin/libdwarf-lite.git
cd libdwarf-lite
git checkout 5dfb2cd2aacf2bf473e5bfea79e41289f88b3a5f # 2.1.0
mkdir build
cd build
cmake .. -DPIC_ALWAYS=On -DBUILD_DWARFDUMP=Off -DCMAKE_PREFIX_PATH=~/scratch/cpptrace-test/resources -DCMAKE_INSTALL_PREFIX=~/scratch/cpptrace-test/resources
make -j
make install

cd ~/scratch/cpptrace-test
git clone https://github.com/jeremy-rifkin/cpptrace.git
cd cpptrace
git checkout v1.0.4
mkdir build
cd build
cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=On -DCPPTRACE_USE_EXTERNAL_LIBDWARF=On -DCMAKE_PREFIX_PATH=~/scratch/cpptrace-test/resources -DCMAKE_INSTALL_PREFIX=~/scratch/cpptrace-test/resources
make -j
make install"><pre>mkdir -p <span class="pl-k">~</span>/scratch/cpptrace-test/resources

<span class="pl-c1">cd</span> <span class="pl-k">~</span>/scratch/cpptrace-test
git clone https://github.com/facebook/zstd.git
<span class="pl-c1">cd</span> zstd
git checkout 63779c798237346c2b245c546c40b72a5a5913fe
<span class="pl-c1">cd</span> build/cmake
mkdir build
<span class="pl-c1">cd</span> build
cmake .. -DCMAKE_INSTALL_PREFIX=<span class="pl-k">~</span>/scratch/cpptrace-test/resources -DZSTD_BUILD_PROGRAMS=On -DZSTD_BUILD_CONTRIB=On -DZSTD_BUILD_TESTS=On -DZSTD_BUILD_STATIC=On -DZSTD_BUILD_SHARED=On -DZSTD_LEGACY_SUPPORT=On
make -j
make install

<span class="pl-c1">cd</span> <span class="pl-k">~</span>/scratch/cpptrace-test
git clone https://github.com/jeremy-rifkin/libdwarf-lite.git
<span class="pl-c1">cd</span> libdwarf-lite
git checkout 5dfb2cd2aacf2bf473e5bfea79e41289f88b3a5f <span class="pl-c"><span class="pl-c">#</span> 2.1.0</span>
mkdir build
<span class="pl-c1">cd</span> build
cmake .. -DPIC_ALWAYS=On -DBUILD_DWARFDUMP=Off -DCMAKE_PREFIX_PATH=<span class="pl-k">~</span>/scratch/cpptrace-test/resources -DCMAKE_INSTALL_PREFIX=<span class="pl-k">~</span>/scratch/cpptrace-test/resources
make -j
make install

<span class="pl-c1">cd</span> <span class="pl-k">~</span>/scratch/cpptrace-test
git clone https://github.com/jeremy-rifkin/cpptrace.git
<span class="pl-c1">cd</span> cpptrace
git checkout v1.0.4
mkdir build
<span class="pl-c1">cd</span> build
cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=On -DCPPTRACE_USE_EXTERNAL_LIBDWARF=On -DCMAKE_PREFIX_PATH=<span class="pl-k">~</span>/scratch/cpptrace-test/resources -DCMAKE_INSTALL_PREFIX=<span class="pl-k">~</span>/scratch/cpptrace-test/resources
make -j
make install</pre></div>
<p dir="auto">The <code>~/scratch/cpptrace-test/resources</code> directory also serves as a bundle you can ship with all the installed files for
cpptrace and its dependencies.</p>
</details>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Package Managers</h2><a id="user-content-package-managers" class="anchor" aria-label="Permalink: Package Managers" href="#package-managers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">Conan</h3><a id="user-content-conan" class="anchor" aria-label="Permalink: Conan" href="#conan"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Cpptrace is available through conan at <a href="https://conan.io/center/recipes/cpptrace" rel="nofollow">https://conan.io/center/recipes/cpptrace</a>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="[requires]
cpptrace/1.0.4
[generators]
CMakeDeps
CMakeToolchain
[layout]
cmake_layout"><pre class="notranslate"><code>[requires]
cpptrace/1.0.4
[generators]
CMakeDeps
CMakeToolchain
[layout]
cmake_layout
</code></pre></div>
<div class="highlight highlight-source-cmake notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# ...
find_package(cpptrace REQUIRED)
# ...
target_link_libraries(YOUR_TARGET cpptrace::cpptrace)"><pre><span class="pl-c"># ...</span>
<span class="pl-k">find_package</span>(cpptrace REQUIRED)
<span class="pl-c"># ...</span>
<span class="pl-k">target_link_libraries</span>(YOUR_TARGET cpptrace::cpptrace)</pre></div>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">Vcpkg</h3><a id="user-content-vcpkg" class="anchor" aria-label="Permalink: Vcpkg" href="#vcpkg"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="vcpkg install cpptrace"><pre class="notranslate"><code>vcpkg install cpptrace
</code></pre></div>
<div class="highlight highlight-source-cmake notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="find_package(cpptrace CONFIG REQUIRED)
target_link_libraries(main PRIVATE cpptrace::cpptrace)"><pre><span class="pl-k">find_package</span>(cpptrace CONFIG REQUIRED)
<span class="pl-k">target_link_libraries</span>(main <span class="pl-e">PRIVATE</span> cpptrace::cpptrace)</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">C++20 Modules</h2><a id="user-content-c20-modules" class="anchor" aria-label="Permalink: C++20 Modules" href="#c20-modules"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Cpptrace supports C++20 modules: <code>import cpptrace;</code>. You'll need a modern toolchain in order to use C++20 modules (i.e.
relatively new compilers, cmake, etc).</p>
<p dir="auto">For features involving macros you will have to <code>#include</code> headers with the macro definitions:</p>
<ul dir="auto">
<li><code>&lt;cpptrace/exceptions_macros.hpp&gt;</code>: <code>CPPTRACE_WRAP</code> and <code>CPPTRACE_WRAP_BLOCK</code></li>
<li><code>&lt;cpptrace/from_current_macros.hpp&gt;</code>: <code>CPPTRACE_TRY</code>, <code>CPPTRACE_CATCH</code>, etc.</li>
</ul>
<div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">Platform Logistics</h1><a id="user-content-platform-logistics" class="anchor" aria-label="Permalink: Platform Logistics" href="#platform-logistics"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Windows and macOS require a little extra work to get everything in the right place.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Windows</h2><a id="user-content-windows" class="anchor" aria-label="Permalink: Windows" href="#windows"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Copying the library <code>.dll</code> on Windows:</p>
<div class="highlight highlight-source-cmake notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Copy the cpptrace.dll on windows to the same directory as the executable for your_target.
# Not required if static linking.
if(WIN32)
  add_custom_command(
    TARGET your_target POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy_if_different
    $&lt;TARGET_FILE:cpptrace::cpptrace&gt;
    $&lt;TARGET_FILE_DIR:your_target&gt;
  )
endif()"><pre><span class="pl-c"># Copy the cpptrace.dll on windows to the same directory as the executable for your_target.</span>
<span class="pl-c"># Not required if static linking.</span>
<span class="pl-k">if</span>(<span class="pl-c1">WIN32</span>)
<span class="pl-k">  add_custom_command</span>(
    <span class="pl-k">TARGET</span> your_target POST_BUILD
    <span class="pl-k">COMMAND</span> <span class="pl-k">${CMAKE_COMMAND}</span> -E copy_if_different
    $&lt;TARGET_FILE:cpptrace::cpptrace&gt;
    $&lt;TARGET_FILE_DIR:your_target&gt;
  )
<span class="pl-k">endif</span>()</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">macOS</h2><a id="user-content-macos" class="anchor" aria-label="Permalink: macOS" href="#macos"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">On macOS, it is recommended to generate a <code>dSYM</code> file containing debug information for your program.
This is not required as cpptrace makes a good effort at finding and reading the debug information
without this, but having a <code>dSYM</code> file is the most robust method.</p>
<p dir="auto">When using Xcode with CMake, this can be done with:</p>
<div class="highlight highlight-source-cmake notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="set_target_properties(your_target PROPERTIES XCODE_ATTRIBUTE_DEBUG_INFORMATION_FORMAT &quot;dwarf-with-dsym&quot;)"><pre><span class="pl-k">set_target_properties</span>(your_target PROPERTIES <span class="pl-e">XCODE_ATTRIBUTE_DEBUG_INFORMATION_FORMAT</span> <span class="pl-s">"dwarf-with-dsym"</span>)</pre></div>
<p dir="auto">Outside of Xcode, this can be done with <code>dsymutil yourbinary</code>:</p>
<div class="highlight highlight-source-cmake notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="# Create a .dSYM file on macOS
if(APPLE)
  add_custom_command(
    TARGET your_target
    POST_BUILD
    COMMAND dsymutil $&lt;TARGET_FILE:your_target&gt;
  )
endif()"><pre><span class="pl-c"># Create a .dSYM file on macOS</span>
<span class="pl-k">if</span>(<span class="pl-c1">APPLE</span>)
<span class="pl-k">  add_custom_command</span>(
    <span class="pl-k">TARGET</span> your_target
    POST_BUILD
    <span class="pl-k">COMMAND</span> dsymutil $&lt;TARGET_FILE:your_target&gt;
  )
<span class="pl-k">endif</span>()</pre></div>
<div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">Library Back-Ends</h1><a id="user-content-library-back-ends" class="anchor" aria-label="Permalink: Library Back-Ends" href="#library-back-ends"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Cpptrace supports a number of back-ends to produce stack traces. Stack traces are produced in roughly three steps:
Unwinding, symbol resolution, and demangling.</p>
<p dir="auto">The library's CMake automatically configures itself for what your system supports. The ideal configuration is as
follows:</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Platform</th>
<th>Unwinding</th>
<th>Symbols</th>
<th>Demangling</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linux</td>
<td><code>_Unwind</code></td>
<td>libdwarf</td>
<td>cxxabi.h</td>
</tr>
<tr>
<td>MacOS</td>
<td><code>_Unwind</code> for gcc, execinfo.h for clang and apple clang</td>
<td>libdwarf</td>
<td>cxxabi.h</td>
</tr>
<tr>
<td>Windows</td>
<td><code>StackWalk64</code></td>
<td>dbghelp</td>
<td>No demangling needed</td>
</tr>
<tr>
<td>MinGW</td>
<td><code>StackWalk64</code></td>
<td>libdwarf + dbghelp</td>
<td>cxxabi.h</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">Support for these back-ends is the main development focus and they should work well. If you want to use a different
back-end such as addr2line, for example, you can configure the library to do so.</p>
<p dir="auto"><strong>Unwinding</strong></p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Library</th>
<th>CMake config</th>
<th>Platforms</th>
<th>Info</th>
</tr>
</thead>
<tbody>
<tr>
<td>libgcc unwind</td>
<td><code>CPPTRACE_UNWIND_WITH_UNWIND</code></td>
<td>linux, macos, mingw</td>
<td>Frames are captured with libgcc's <code>_Unwind_Backtrace</code>, which currently produces the most accurate stack traces on gcc/clang/mingw. Libgcc is often linked by default, and llvm has something equivalent.</td>
</tr>
<tr>
<td>execinfo.h</td>
<td><code>CPPTRACE_UNWIND_WITH_EXECINFO</code></td>
<td>linux, macos</td>
<td>Frames are captured with <code>execinfo.h</code>'s <code>backtrace</code>, part of libc on linux/unix systems.</td>
</tr>
<tr>
<td>winapi</td>
<td><code>CPPTRACE_UNWIND_WITH_WINAPI</code></td>
<td>windows, mingw</td>
<td>Frames are captured with <code>CaptureStackBackTrace</code>.</td>
</tr>
<tr>
<td>dbghelp</td>
<td><code>CPPTRACE_UNWIND_WITH_DBGHELP</code></td>
<td>windows, mingw</td>
<td>Frames are captured with <code>StackWalk64</code>.</td>
</tr>
<tr>
<td>libunwind</td>
<td><code>CPPTRACE_UNWIND_WITH_LIBUNWIND</code></td>
<td>linux, macos, windows, mingw</td>
<td>Frames are captured with <a href="https://github.com/libunwind/libunwind">libunwind</a>. <strong>Note:</strong> This is the only back-end that requires a library to be installed by the user, and a <code>CMAKE_PREFIX_PATH</code> may also be needed.</td>
</tr>
<tr>
<td>N/A</td>
<td><code>CPPTRACE_UNWIND_WITH_NOTHING</code></td>
<td>all</td>
<td>Unwinding is not done, stack traces will be empty.</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">Some back-ends (execinfo and <code>CaptureStackBackTrace</code>) require a fixed buffer has to be created to read addresses into
while unwinding. By default the buffer can hold addresses for 400 frames (beyond the <code>skip</code> frames). This is
configurable with <code>CPPTRACE_HARD_MAX_FRAMES</code>.</p>
<p dir="auto"><strong>Symbol resolution</strong></p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Library</th>
<th>CMake config</th>
<th>Platforms</th>
<th>Info</th>
</tr>
</thead>
<tbody>
<tr>
<td>libdwarf</td>
<td><code>CPPTRACE_GET_SYMBOLS_WITH_LIBDWARF</code></td>
<td>linux, macos, mingw</td>
<td>Libdwarf is the preferred method for symbol resolution for cpptrace. Cpptrace will get it via FetchContent or find_package depending on <code>CPPTRACE_USE_EXTERNAL_LIBDWARF</code>.</td>
</tr>
<tr>
<td>dbghelp</td>
<td><code>CPPTRACE_GET_SYMBOLS_WITH_DBGHELP</code></td>
<td>windows</td>
<td>Dbghelp.h is the preferred method for symbol resolution on windows under msvc/clang and is supported on all windows machines.</td>
</tr>
<tr>
<td>libbacktrace</td>
<td><code>CPPTRACE_GET_SYMBOLS_WITH_LIBBACKTRACE</code></td>
<td>linux, macos*, mingw*</td>
<td>Libbacktrace is already installed on most systems or available through the compiler directly. For clang you must specify the absolute path to <code>backtrace.h</code> using <code>CPPTRACE_BACKTRACE_PATH</code>.</td>
</tr>
<tr>
<td>addr2line</td>
<td><code>CPPTRACE_GET_SYMBOLS_WITH_ADDR2LINE</code></td>
<td>linux, macos, mingw</td>
<td>Symbols are resolved by invoking <code>addr2line</code> (or <code>atos</code> on mac) via <code>fork()</code> (on linux/unix, and <code>popen</code> under mingw).</td>
</tr>
<tr>
<td>libdl</td>
<td><code>CPPTRACE_GET_SYMBOLS_WITH_LIBDL</code></td>
<td>linux, macos</td>
<td>Libdl uses dynamic export information. Compiling with <code>-rdynamic</code> is needed for symbol information to be retrievable. Line numbers won't be retrievable.</td>
</tr>
<tr>
<td>N/A</td>
<td><code>CPPTRACE_GET_SYMBOLS_WITH_NOTHING</code></td>
<td>all</td>
<td>No attempt is made to resolve symbols.</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto">*: Requires installation</p>
<p dir="auto">One back-end should be used. For MinGW <code>CPPTRACE_GET_SYMBOLS_WITH_LIBDWARF</code> and <code>CPPTRACE_GET_SYMBOLS_WITH_DBGHELP</code> can
be used in conjunction.</p>
<p dir="auto">Note for addr2line: By default cmake will resolve an absolute path to addr2line to bake into the library. This path can
be configured with <code>CPPTRACE_ADDR2LINE_PATH</code>, or <code>CPPTRACE_ADDR2LINE_SEARCH_SYSTEM_PATH</code> can be used to have the library
search the system path for <code>addr2line</code> at runtime. This is not the default to prevent against path injection attacks.</p>
<p dir="auto"><strong>Demangling</strong></p>
<p dir="auto">Lastly, depending on other back-ends used a demangler back-end may be needed.</p>
<markdown-accessiblity-table><table>
<thead>
<tr>
<th>Library</th>
<th>CMake config</th>
<th>Platforms</th>
<th>Info</th>
</tr>
</thead>
<tbody>
<tr>
<td>cxxabi.h</td>
<td><code>CPPTRACE_DEMANGLE_WITH_CXXABI</code></td>
<td>Linux, macos, mingw</td>
<td>Should be available everywhere other than <a href="https://godbolt.org/z/93ca9rcdz" rel="nofollow">msvc</a>.</td>
</tr>
<tr>
<td>dbghelp.h</td>
<td><code>CPPTRACE_DEMANGLE_WITH_WINAPI</code></td>
<td>Windows</td>
<td>Demangle with <code>UnDecorateSymbolName</code>.</td>
</tr>
<tr>
<td>N/A</td>
<td><code>CPPTRACE_DEMANGLE_WITH_NOTHING</code></td>
<td>all</td>
<td>Don't attempt to do anything beyond what the symbol resolution back-end does.</td>
</tr>
</tbody>
</table></markdown-accessiblity-table>
<p dir="auto"><strong>More?</strong></p>
<p dir="auto">There are plenty more libraries that can be used for unwinding, parsing debug information, and demangling. In the future
more back-ends can be added. Ideally this library can "just work" on systems, without additional installation work.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Summary of Library Configurations</h2><a id="user-content-summary-of-library-configurations" class="anchor" aria-label="Permalink: Summary of Library Configurations" href="#summary-of-library-configurations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Summary of all library configuration options:</p>
<p dir="auto">Back-ends:</p>
<ul dir="auto">
<li><code>CPPTRACE_GET_SYMBOLS_WITH_LIBDWARF=On/Off</code></li>
<li><code>CPPTRACE_GET_SYMBOLS_WITH_DBGHELP=On/Off</code></li>
<li><code>CPPTRACE_GET_SYMBOLS_WITH_LIBBACKTRACE=On/Off</code></li>
<li><code>CPPTRACE_GET_SYMBOLS_WITH_ADDR2LINE=On/Off</code></li>
<li><code>CPPTRACE_GET_SYMBOLS_WITH_LIBDL=On/Off</code></li>
<li><code>CPPTRACE_GET_SYMBOLS_WITH_NOTHING=On/Off</code></li>
<li><code>CPPTRACE_UNWIND_WITH_UNWIND=On/Off</code></li>
<li><code>CPPTRACE_UNWIND_WITH_LIBUNWIND=On/Off</code></li>
<li><code>CPPTRACE_UNWIND_WITH_EXECINFO=On/Off</code></li>
<li><code>CPPTRACE_UNWIND_WITH_WINAPI=On/Off</code></li>
<li><code>CPPTRACE_UNWIND_WITH_DBGHELP=On/Off</code></li>
<li><code>CPPTRACE_UNWIND_WITH_NOTHING=On/Off</code></li>
<li><code>CPPTRACE_DEMANGLE_WITH_CXXABI=On/Off</code></li>
<li><code>CPPTRACE_DEMANGLE_WITH_WINAPI=On/Off</code></li>
<li><code>CPPTRACE_DEMANGLE_WITH_NOTHING=On/Off</code></li>
</ul>
<p dir="auto">Back-end configuration:</p>
<ul dir="auto">
<li><code>CPPTRACE_BACKTRACE_PATH=&lt;string&gt;</code>: Path to libbacktrace backtrace.h, needed when compiling with clang/</li>
<li><code>CPPTRACE_HARD_MAX_FRAMES=&lt;number&gt;</code>: Some back-ends write to a fixed-size buffer. This is the size of that buffer.
Default is <code>400</code>.</li>
<li><code>CPPTRACE_ADDR2LINE_PATH=&lt;string&gt;</code>: Specify the absolute path to the addr2line binary for cpptrace to invoke. By
default the config script will search for a binary and use that absolute path (this is to prevent against path
injection).</li>
<li><code>CPPTRACE_ADDR2LINE_SEARCH_SYSTEM_PATH=On/Off</code>: Specifies whether cpptrace should let the system search the PATH
environment variable directories for the binary.</li>
</ul>
<p dir="auto">Other useful configurations:</p>
<ul dir="auto">
<li><code>CPPTRACE_BUILD_SHARED=On/Off</code>: Override for <code>BUILD_SHARED_LIBS</code>.</li>
<li><code>CPPTRACE_INCLUDES_WITH_SYSTEM=On/Off</code>: Marks cpptrace headers as <code>SYSTEM</code> which will hide any warnings that aren't
the fault of your project. Defaults to On.</li>
<li><code>CPPTRACE_INSTALL_CMAKEDIR</code>: Override for the installation path for the cmake configs.</li>
<li><code>CPPTRACE_USE_EXTERNAL_LIBDWARF=On/Off</code>: Get libdwarf from <code>find_package</code> rather than <code>FetchContent</code>.</li>
<li><code>CPPTRACE_POSITION_INDEPENDENT_CODE=On/Off</code>: Compile the library as a position independent code (PIE). Defaults to On.</li>
<li><code>CPPTRACE_STD_FORMAT=On/Off</code>: Control inclusion of <code>&lt;format&gt;</code> and provision of <code>std::formatter</code> specializations by
cpptrace.hpp. This can also be controlled with the macro <code>CPPTRACE_NO_STD_FORMAT</code>.</li>
</ul>
<p dir="auto">Testing:</p>
<ul dir="auto">
<li><code>CPPTRACE_BUILD_TESTING</code> Build small demo and test program</li>
<li><code>CPPTRACE_BUILD_TEST_RDYNAMIC</code> Use <code>-rdynamic</code> when compiling the test program</li>
</ul>
<div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">Testing Methodology</h1><a id="user-content-testing-methodology" class="anchor" aria-label="Permalink: Testing Methodology" href="#testing-methodology"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Cpptrace currently uses integration and functional testing, building and running under every combination of back-end
options. The implementation is based on <a href="https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs">github actions matrices</a> and driven by python scripts located in the
<a href="ci/"><code>ci/</code></a> folder. Testing used to be done by github actions matrices directly, however, launching hundreds of two
second jobs was extremely inefficient. Test outputs are compared against expected outputs located in
<a href="test/expected/"><code>test/expected/</code></a>. Stack trace addresses may point to the address after an instruction depending on the
unwinding back-end, and the python script will check for an exact or near-match accordingly.</p>
<div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">Notes About the Library</h1><a id="user-content-notes-about-the-library" class="anchor" aria-label="Permalink: Notes About the Library" href="#notes-about-the-library"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">For the most part I'm happy with the state of the library. But I'm sure that there is room for improvement and issues
will exist. If you encounter any issue, please let me know! If you find any pain-points in the library, please let me
know that too.</p>
<p dir="auto">A note about performance: For handling of DWARF symbols there is a lot of room to explore for performance optimizations
and time-memory tradeoffs. If you find the current implementation is either slow or using too much memory, I'd be happy
to explore some of these options.</p>
<p dir="auto">A couple things I'd like to improve in the future:</p>
<ul dir="auto">
<li>On Windows when collecting symbols with dbghelp (msvc/clang) parameter types are almost perfect but due to limitations
in dbghelp the library cannot accurately show const and volatile qualifiers or rvalue references (these appear as
pointers).</li>
</ul>
<div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">FAQ</h1><a id="user-content-faq" class="anchor" aria-label="Permalink: FAQ" href="#faq"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">What about C++23 <code>&lt;stacktrace&gt;</code>?</h2><a id="user-content-what-about-c23-stacktrace" class="anchor" aria-label="Permalink: What about C++23 &lt;stacktrace&gt;?" href="#what-about-c23-stacktrace"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Some day C++23's <code>&lt;stacktrace&gt;</code> will be ubiquitous. And maybe one day the msvc implementation will be acceptable.
The original motivation for cpptrace was to support projects using older C++ standards and as the library has grown its
functionality has extended beyond the standard library's implementation.</p>
<p dir="auto">Cpptrace provides functionality beyond what the standard library provides and what implementations provide, such as:</p>
<ul dir="auto">
<li>Walking inlined function calls</li>
<li>Providing a lightweight interface for "raw traces"</li>
<li>Resolving function parameter types</li>
<li>Providing traced exception objects</li>
<li>Providing an API for signal-safe stacktrace generation</li>
<li>Providing a way to retrieve stack traces from arbitrary exceptions, not just special cpptrace traced exception
objects. This is a feature coming to C++26, but cpptrace provides a solution for C++11.</li>
</ul>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">What does cpptrace have over other C++ stacktrace libraries?</h2><a id="user-content-what-does-cpptrace-have-over-other-c-stacktrace-libraries" class="anchor" aria-label="Permalink: What does cpptrace have over other C++ stacktrace libraries?" href="#what-does-cpptrace-have-over-other-c-stacktrace-libraries"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Other C++ stacktrace libraries, such as boost stacktrace and backward-cpp, fall short when it comes to portability and
ease of use. In testing, I found neither to provide adequate coverage of various environments. Even when they can be
made to work in an environment they require manual configuration from the end-user, possibly requiring manual
installation of third-party dependencies. This is a highly undesirable burden to impose on users, especially when it is
for a software package which just provides diagnostics as opposed to core functionality. Additionally, cpptrace provides
support for resolving inlined calls by default for DWARF symbols (boost does not do this, backward-cpp can do this but
only for some back-ends), better support for resolving full function signatures, and nicer API, among other features.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">I'm getting undefined standard library symbols like <code>std::__1::basic_string</code> on MacOS</h2><a id="user-content-im-getting-undefined-standard-library-symbols-like-std__1basic_string-on-macos" class="anchor" aria-label="Permalink: I'm getting undefined standard library symbols like std::__1::basic_string on MacOS" href="#im-getting-undefined-standard-library-symbols-like-std__1basic_string-on-macos"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">If you see a linker error along the lines of the following on MacOS then it's highly likely you are mixing standard
library ABIs.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Undefined symbols for architecture arm64:
  &quot;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;::find(char, unsigned long) const&quot;, referenced from:
      cpptrace::detail::demangle(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, bool) in libcpptrace.a(demangle_with_cxxabi.cpp.o)
      cpptrace::detail::snippet_manager::build_line_table() in libcpptrace.a(snippet.cpp.o)"><pre class="notranslate"><code>Undefined symbols for architecture arm64:
  "std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;::find(char, unsigned long) const", referenced from:
      cpptrace::detail::demangle(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, bool) in libcpptrace.a(demangle_with_cxxabi.cpp.o)
      cpptrace::detail::snippet_manager::build_line_table() in libcpptrace.a(snippet.cpp.o)
</code></pre></div>
<p dir="auto">This can happen when using apple clang to compile cpptrace and gcc to compile your code, or vice versa. The reason is
that apple clang defaults to libc++ and gcc defaults to libstdc++ and these two standard library implementations are not
ABI-compatible. To resolve this, ensure you are compiling both cpptrace and your code with the same standard library by
either using the same compiler for both or using <code>-stdlib=libc++</code>/<code>-stdlib=libstdc++</code> to control which standard library
is used.</p>
<div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">Contributing</h1><a id="user-content-contributing" class="anchor" aria-label="Permalink: Contributing" href="#contributing"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">I'm grateful for the help I've received with this library and I welcome contributions! For information on contributing
please refer to <a href="./CONTRIBUTING.md">CONTRIBUTING.md</a>.</p>
<div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">License</h1><a id="user-content-license" class="anchor" aria-label="Permalink: License" href="#license"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This library is under the MIT license.</p>
<p dir="auto">Cpptrace uses libdwarf on linux, macos, and mingw/cygwin unless configured to use something else. If this library is
statically linked with libdwarf then the library's binary will itself be LGPL.</p>
</article></div>