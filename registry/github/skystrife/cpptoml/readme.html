<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">cpptoml</h1><a id="user-content-cpptoml" class="anchor-element" aria-label="Permalink: cpptoml" href="#cpptoml"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">A header-only library for parsing <a href="https://github.com/toml-lang/toml">TOML</a> configuration files.</p>
<p dir="auto">Targets: <a href="https://github.com/toml-lang/toml/blob/master/versions/en/toml-v0.5.0.md">TOML v0.5.0</a> as of August 2018.</p>
<p dir="auto">This includes support for the new DateTime format, inline tables,
multi-line basic and raw strings, digit separators, hexadecimal integers,
octal integers, binary integers, and float special values.</p>
<p dir="auto">Alternatives:</p>
<ul dir="auto">
<li><a href="https://github.com/ToruNiina/Boost.toml">Boost.toml</a> is a C++ implementation of a TOML parser using
the Boost library. As of writing, it supports v0.5.0 as well.</li>
<li><a href="https://github.com/evilncrazy/ctoml">ctoml</a> is a C++11 implementation of a TOML parser, but only
supports v0.2.0.</li>
<li><a href="https://github.com/ajwans/libtoml">libtoml</a> is a C implementation of a TOML parser, which can be
linked to from your C++ programs easily. As of April 2016, it supports
v0.4.0.</li>
<li><a href="https://github.com/mayah/tinytoml">tinytoml</a> is a C++11 implementation of a TOML parser, which
also supports v0.4.0 as of November 2015.</li>
</ul>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Build Status</h2><a id="user-content-build-status" class="anchor-element" aria-label="Permalink: Build Status" href="#build-status"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="https://travis-ci.org/skystrife/cpptoml" rel="nofollow"><img src="https://camo.githubusercontent.com/f3268ab64c7cc96fc4cbaabb8cb2458ea90e33b322abb46f02c9d6975b09175b/68747470733a2f2f7472617669732d63692e6f72672f736b797374726966652f637070746f6d6c2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/skystrife/cpptoml.svg?branch=master" style="max-width: 100%;"></a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Test Results</h2><a id="user-content-test-results" class="anchor-element" aria-label="Permalink: Test Results" href="#test-results"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">From <a href="https://github.com/BurntSushi/toml-test">the toml-test suite</a>:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="126 passed, 0 failed"><pre class="notranslate"><code>126 passed, 0 failed
</code></pre></div>
<p dir="auto">We also currently maintain (but hopefully not indefinitely!) a <a href="https://github.com/skystrife/toml-test">fork of the
toml-test suite</a> that adds tests for features and
clarifications that have been added to the TOML spec more recently than
toml-test has been updated. We pass every test there.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="148 passed, 0 failed"><pre class="notranslate"><code>148 passed, 0 failed
</code></pre></div>
<div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">Compilation</h1><a id="user-content-compilation" class="anchor-element" aria-label="Permalink: Compilation" href="#compilation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Requires a well conforming C++11 compiler. On OSX this means clang++ with
libc++ and libc++abi (the default clang installed with XCode's command line
tools is sufficient).</p>
<p dir="auto">On Linux, you should be able to use g++ &gt;= 4.8.x, or clang++ with libc++
and libc++abi (if your package manager supplies this; most don't).</p>
<p dir="auto">Compiling the examples can be done with cmake:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="mkdir build
cd build
cmake ../
make"><pre class="notranslate"><code>mkdir build
cd build
cmake ../
make
</code></pre></div>
<div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">Example Usage</h1><a id="user-content-example-usage" class="anchor-element" aria-label="Permalink: Example Usage" href="#example-usage"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">To parse a configuration file from a file, you can do the following:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="auto config = cpptoml::parse_file(&quot;config.toml&quot;);"><pre><span class="pl-k">auto</span> config = cpptoml::parse_file(<span class="pl-s"><span class="pl-pds">"</span>config.toml<span class="pl-pds">"</span></span>);</pre></div>
<p dir="auto"><code>parse_file()</code> returns a (shared pointer to a) <code>cpptoml::table</code>, which you
can then query. It will throw an instance of <code>cpptoml::parse_exception</code> in
the event that the file failed to parse, and the exception message should
contain the line number the error occurred as well as a description of the
error.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Obtaining Basic Values</h2><a id="user-content-obtaining-basic-values" class="anchor-element" aria-label="Permalink: Obtaining Basic Values" href="#obtaining-basic-values"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">You can find basic values like so:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="auto val = config-&gt;get_as&lt;int64_t&gt;(&quot;my-int&quot;);
// val is a cpptoml::option&lt;int64_t&gt;

if (val)
{
    // *val is the integer value for the key &quot;my-int&quot;
}
else
{
    // &quot;my-int&quot; either did not exist or was not an integer
}"><pre><span class="pl-k">auto</span> val = config-&gt;get_as&lt;<span class="pl-c1">int64_t</span>&gt;(<span class="pl-s"><span class="pl-pds">"</span>my-int<span class="pl-pds">"</span></span>);
<span class="pl-c"><span class="pl-c">//</span> val is a cpptoml::option&lt;int64_t&gt;</span>

<span class="pl-k">if</span> (val)
{
    <span class="pl-c"><span class="pl-c">//</span> *val is the integer value for the key "my-int"</span>
}
<span class="pl-k">else</span>
{
    <span class="pl-c"><span class="pl-c">//</span> "my-int" either did not exist or was not an integer</span>
}</pre></div>
<p dir="auto">To simplify things, you can specify default a default value using the
<code>value_or</code> function on the <code>option</code>:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="auto baz = config-&gt;get_as&lt;double&gt;(&quot;baz&quot;).value_or(0.5);
// baz is now the double value for key &quot;baz&quot;, if it exists, or 0.5 otherwise"><pre><span class="pl-k">auto</span> baz = config-&gt;get_as&lt;<span class="pl-k">double</span>&gt;(<span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span>).value_or(<span class="pl-c1">0.5</span>);
<span class="pl-c"><span class="pl-c">//</span> baz is now the double value for key "baz", if it exists, or 0.5 otherwise</span></pre></div>
<p dir="auto">cpptoml has extended support for dates and times beyond the TOML v0.4.0
spec. Specifically, it supports</p>
<ul dir="auto">
<li>Local Date (<code>local_date</code>), which simply represents a date and lacks any time
information, e.g. <code>1980-08-02</code>;</li>
<li>Local Time (<code>local_time</code>), which simply represents a time and lacks any
date or zone information, e.g. <code>12:10:03.001</code>;</li>
<li>Local Date-time (<code>local_datetime</code>), which represents a date and a time,
but lacks zone information, e.g. <code>1980-08-02T12:10:03.001</code>;</li>
<li>and Offset Date-time (<code>offset_datetime</code>), which represents a date, a
time, and timezone information, e.g. <code>1980-08-02T12:10:03.001-07:00</code></li>
</ul>
<p dir="auto">Here are the fields of the date/time objects in cpptoml:</p>
<ul dir="auto">
<li>year (<code>local_date</code>, <code>local_datetime</code>, <code>offset_datetime</code>)</li>
<li>month (<code>local_date</code>, <code>local_datetime</code>, <code>offset_datetime</code>)</li>
<li>day (<code>local_date</code>, <code>local_datetime</code>, <code>offset_datetime</code>)</li>
<li>hour (<code>local_time</code>, <code>local_datetime</code>, <code>offset_datetime</code>)</li>
<li>minute (<code>local_time</code>, <code>local_datetime</code>, <code>offset_datetime</code>)</li>
<li>second (<code>local_time</code>, <code>local_datetime</code>, <code>offset_datetime</code>)</li>
<li>microsecond (<code>local_time</code>, <code>local_datetime</code>, <code>offset_datetime</code>)</li>
<li>hour_offset (<code>offset_datetime</code>)</li>
<li>minute_offset (<code>offset_datetime</code>)</li>
</ul>
<p dir="auto">There are convenience functions <code>cpptoml::offset_datetime::from_zoned()</code> and
<code>cpptoml::offset_datetime::from_utc()</code> to convert <code>struct tm</code>s to
<code>cpptoml::offset_datetime</code>s.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Nested Tables</h2><a id="user-content-nested-tables" class="anchor-element" aria-label="Permalink: Nested Tables" href="#nested-tables"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">If you want to look up things in nested tables, there are two ways of doing
this. Suppose you have the following structure:</p>
<div class="highlight highlight-source-toml notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="[first-table]
key1 = 0.1
key2 = 1284

[first-table.inner]
key3 = &quot;hello world&quot;"><pre>[<span class="pl-en">first-table</span>]
<span class="pl-smi">key1</span> = <span class="pl-c1">0.1</span>
<span class="pl-smi">key2</span> = <span class="pl-c1">1284</span>

[<span class="pl-en">first-table</span>.<span class="pl-en">inner</span>]
<span class="pl-smi">key3</span> = <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span></pre></div>
<p dir="auto">Here's an idiomatic way of obtaining all three keys' values:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="auto config = cpptoml::parse_file(&quot;config.toml&quot;);
auto key1 = config-&gt;get_qualified_as&lt;double&gt;(&quot;first-table.key1&quot;);
auto key2 = config-&gt;get_qualified_as&lt;int&gt;(&quot;first-table.key2&quot;);
auto key3 = config-&gt;get_qualified_as&lt;std::string&gt;(&quot;first-table.inner.key3&quot;);"><pre><span class="pl-k">auto</span> config = cpptoml::parse_file(<span class="pl-s"><span class="pl-pds">"</span>config.toml<span class="pl-pds">"</span></span>);
<span class="pl-k">auto</span> key1 = config-&gt;get_qualified_as&lt;<span class="pl-k">double</span>&gt;(<span class="pl-s"><span class="pl-pds">"</span>first-table.key1<span class="pl-pds">"</span></span>);
<span class="pl-k">auto</span> key2 = config-&gt;get_qualified_as&lt;<span class="pl-k">int</span>&gt;(<span class="pl-s"><span class="pl-pds">"</span>first-table.key2<span class="pl-pds">"</span></span>);
<span class="pl-k">auto</span> key3 = config-&gt;get_qualified_as&lt;std::string&gt;(<span class="pl-s"><span class="pl-pds">"</span>first-table.inner.key3<span class="pl-pds">"</span></span>);</pre></div>
<p dir="auto">(Note that, because the TOML spec allows for "." to occur in a table name,
you won't <em>always</em> be able to do this for any nested key, but in practice
you should be fine.)</p>
<p dir="auto">A slightly more verbose way of getting them would be to first obtain the
individual tables, and then query those individual tables for their keys
like so:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="auto config = cpptoml::parse_file(&quot;config.toml&quot;);

auto first = config-&gt;get_table(&quot;first-table&quot;);
auto key1 = first-&gt;get_as&lt;double&gt;(&quot;key1&quot;);
auto key2 = first-&gt;get_as&lt;int&gt;(&quot;key2&quot;);

auto inner = first-&gt;get_table(&quot;inner&quot;);
auto key3 = inner-&gt;get_as&lt;std::string&gt;(&quot;key3&quot;);"><pre><span class="pl-k">auto</span> config = cpptoml::parse_file(<span class="pl-s"><span class="pl-pds">"</span>config.toml<span class="pl-pds">"</span></span>);

<span class="pl-k">auto</span> first = config-&gt;<span class="pl-en">get_table</span>(<span class="pl-s"><span class="pl-pds">"</span>first-table<span class="pl-pds">"</span></span>);
<span class="pl-k">auto</span> key1 = first-&gt;get_as&lt;<span class="pl-k">double</span>&gt;(<span class="pl-s"><span class="pl-pds">"</span>key1<span class="pl-pds">"</span></span>);
<span class="pl-k">auto</span> key2 = first-&gt;get_as&lt;<span class="pl-k">int</span>&gt;(<span class="pl-s"><span class="pl-pds">"</span>key2<span class="pl-pds">"</span></span>);

<span class="pl-k">auto</span> inner = first-&gt;<span class="pl-en">get_table</span>(<span class="pl-s"><span class="pl-pds">"</span>inner<span class="pl-pds">"</span></span>);
<span class="pl-k">auto</span> key3 = inner-&gt;get_as&lt;std::string&gt;(<span class="pl-s"><span class="pl-pds">"</span>key3<span class="pl-pds">"</span></span>);</pre></div>
<p dir="auto">The function <code>get_table_qualified</code> also exists, so obtaining the inner
table could be written as</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="auto inner2 = config-&gt;get_table_qualified(&quot;first-table.inner&quot;);"><pre><span class="pl-k">auto</span> inner2 = config-&gt;<span class="pl-en">get_table_qualified</span>(<span class="pl-s"><span class="pl-pds">"</span>first-table.inner<span class="pl-pds">"</span></span>);</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Arrays of Values</h2><a id="user-content-arrays-of-values" class="anchor-element" aria-label="Permalink: Arrays of Values" href="#arrays-of-values"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Suppose you had a configuration file like the following:</p>
<div class="highlight highlight-source-toml notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="arr = [1, 2, 3, 4, 5]
mixed-arr = [[1, 2, 3, 4, 5], [&quot;hello&quot;, &quot;world&quot;], [0.1, 1.1, 2.1]]"><pre><span class="pl-smi">arr</span> = [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>]
<span class="pl-smi">mixed-arr</span> = [[<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>], [<span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>world<span class="pl-pds">"</span></span>], [<span class="pl-c1">0.1</span>, <span class="pl-c1">1.1</span>, <span class="pl-c1">2.1</span>]]</pre></div>
<p dir="auto">To obtain an array of values, you can do the following:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="auto config = cpptoml::parse_file(&quot;config.toml&quot;);

auto vals = config-&gt;get_array_of&lt;int64_t&gt;(&quot;arr&quot;);
// vals is a cpptoml::option&lt;std::vector&lt;int64_t&gt;&gt;

for (const auto&amp; val : *vals)
{
    // val is an int64_t
}"><pre><span class="pl-k">auto</span> config = cpptoml::parse_file(<span class="pl-s"><span class="pl-pds">"</span>config.toml<span class="pl-pds">"</span></span>);

<span class="pl-k">auto</span> vals = config-&gt;get_array_of&lt;<span class="pl-c1">int64_t</span>&gt;(<span class="pl-s"><span class="pl-pds">"</span>arr<span class="pl-pds">"</span></span>);
<span class="pl-c"><span class="pl-c">//</span> vals is a cpptoml::option&lt;std::vector&lt;int64_t&gt;&gt;</span>

<span class="pl-k">for</span> (<span class="pl-k">const</span> <span class="pl-k">auto</span>&amp; val : *vals)
{
    <span class="pl-c"><span class="pl-c">//</span> val is an int64_t</span>
}</pre></div>
<p dir="auto"><code>get_array_of</code> will return an <code>option&lt;vector&lt;T&gt;&gt;</code>, which will be empty if
the key does not exist, is not of the array type, or contains values that
are not of type <code>T</code>.</p>
<p dir="auto">For nested arrays, it looks like the following:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="auto nested = config-&gt;get_array_of&lt;cpptoml::array&gt;(&quot;mixed-arr&quot;);

auto ints = (*nested)[0]-&gt;get_array_of&lt;int64_t&gt;();
// ints is a cpptoml::option&lt;std::vector&lt;int64_t&gt;&gt;

auto strings = (*nested)[1]-&gt;get_array_of&lt;std::string&gt;();
auto doubles = (*nested)[2]-&gt;get_array_of&lt;double&gt;();"><pre><span class="pl-k">auto</span> nested = config-&gt;get_array_of&lt;cpptoml::array&gt;(<span class="pl-s"><span class="pl-pds">"</span>mixed-arr<span class="pl-pds">"</span></span>);

<span class="pl-k">auto</span> ints = (*nested)[<span class="pl-c1">0</span>]-&gt;get_array_of&lt;<span class="pl-c1">int64_t</span>&gt;();
<span class="pl-c"><span class="pl-c">//</span> ints is a cpptoml::option&lt;std::vector&lt;int64_t&gt;&gt;</span>

<span class="pl-k">auto</span> strings = (*nested)[<span class="pl-c1">1</span>]-&gt;get_array_of&lt;std::string&gt;();
<span class="pl-k">auto</span> doubles = (*nested)[<span class="pl-c1">2</span>]-&gt;get_array_of&lt;<span class="pl-k">double</span>&gt;();</pre></div>
<p dir="auto">There is also a <code>get_qualified_array_of</code> for simplifying arrays located
inside nested tables.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Arrays of Tables</h2><a id="user-content-arrays-of-tables" class="anchor-element" aria-label="Permalink: Arrays of Tables" href="#arrays-of-tables"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Suppose you had a configuration file like the following:</p>
<div class="highlight highlight-source-toml notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="[[table-array]]
key1 = &quot;hello&quot;

[[table-array]]
key1 = &quot;can you hear me&quot;"><pre>[[<span class="pl-en">table-array</span>]]
<span class="pl-smi">key1</span> = <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>

[[<span class="pl-en">table-array</span>]]
<span class="pl-smi">key1</span> = <span class="pl-s"><span class="pl-pds">"</span>can you hear me<span class="pl-pds">"</span></span></pre></div>
<p dir="auto">Arrays of tables are represented as a separate type in <code>cpptoml</code>. They can
be obtained like so:</p>
<div class="highlight highlight-source-c++ notranslate position-relative overflow-auto" dir="auto" data-snippet-clipboard-copy-content="auto config = cpptoml::parse_file(&quot;config.toml&quot;);

auto tarr = config-&gt;get_table_array(&quot;table-array&quot;);

for (const auto&amp; table : *tarr)
{
    // *table is a cpptoml::table
    auto key1 = table-&gt;get_as&lt;std::string&gt;(&quot;key1&quot;);
}"><pre><span class="pl-k">auto</span> config = cpptoml::parse_file(<span class="pl-s"><span class="pl-pds">"</span>config.toml<span class="pl-pds">"</span></span>);

<span class="pl-k">auto</span> tarr = config-&gt;<span class="pl-en">get_table_array</span>(<span class="pl-s"><span class="pl-pds">"</span>table-array<span class="pl-pds">"</span></span>);

<span class="pl-k">for</span> (<span class="pl-k">const</span> <span class="pl-k">auto</span>&amp; table : *tarr)
{
    <span class="pl-c"><span class="pl-c">//</span> *table is a cpptoml::table</span>
    <span class="pl-k">auto</span> key1 = table-&gt;<span class="pl-smi">get_as</span>&lt;std::string&gt;(<span class="pl-s"><span class="pl-pds">"</span>key1<span class="pl-pds">"</span></span>);
}</pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">More Examples</h2><a id="user-content-more-examples" class="anchor-element" aria-label="Permalink: More Examples" href="#more-examples"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">You can look at the files files <code>parse.cpp</code>, <code>parse_stdin.cpp</code>, and
<code>build_toml.cpp</code> in the root directory for some more examples.</p>
<p dir="auto"><code>parse_stdin.cpp</code> shows how to use the visitor pattern to traverse an
entire <code>cpptoml::table</code> for serialization.</p>
<p dir="auto"><code>build_toml.cpp</code> shows how to construct a TOML representation in-memory and
then serialize it to a stream.</p>
</article></div>