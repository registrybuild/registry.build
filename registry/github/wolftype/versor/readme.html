<div id="readme" class="md" data-path="README.md"><article class="markdown-body entry-content container-lg" itemprop="text"><p dir="auto">CSS: scripts/style.css</p>
&lt;script type="text/javascript"
  src="<a href="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;" rel="nofollow">https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"&gt;</a>
&lt;/script&gt;
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/781acfc7afa13d7c5087595cf09e10a4be2523c61159bf8979d886dddf3c1436/687474703a2f2f766572736f722e6d61742e756373622e6564752f7265736f75726365732f696d616765732f6373686170652e676966"><img src="https://camo.githubusercontent.com/781acfc7afa13d7c5087595cf09e10a4be2523c61159bf8979d886dddf3c1436/687474703a2f2f766572736f722e6d61742e756373622e6564752f7265736f75726365732f696d616765732f6373686170652e676966" width="80" data-animated-image="" data-canonical-src="http://versor.mat.ucsb.edu/resources/images/cshape.gif" style="max-width: 100%;"></a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/3d3bbec604d0bbdd11357b4b910eb73c681e85466c876c8a688277742c0fcc48/687474703a2f2f766572736f722e6d61742e756373622e6564752f7265736f75726365732f696d616765732f7477696e655f302e676966"><img src="https://camo.githubusercontent.com/3d3bbec604d0bbdd11357b4b910eb73c681e85466c876c8a688277742c0fcc48/687474703a2f2f766572736f722e6d61742e756373622e6564752f7265736f75726365732f696d616765732f7477696e655f302e676966" width="100" data-animated-image="" data-canonical-src="http://versor.mat.ucsb.edu/resources/images/twine_0.gif" style="max-width: 100%;"></a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/d4670a9e52dcbdb89ca4297b6cf9c3a5fb78ec5963e921f2a29e0761f1940848/687474703a2f2f766572736f722e6d61742e756373622e6564752f7265736f75726365732f696d616765732f74776973745f30345f62772e676966"><img src="https://camo.githubusercontent.com/d4670a9e52dcbdb89ca4297b6cf9c3a5fb78ec5963e921f2a29e0761f1940848/687474703a2f2f766572736f722e6d61742e756373622e6564752f7265736f75726365732f696d616765732f74776973745f30345f62772e676966" width="400" data-animated-image="" data-canonical-src="http://versor.mat.ucsb.edu/resources/images/twist_04_bw.gif" style="max-width: 100%;"></a></p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/58c09b4345f79c42a4e2a97ad3bd766492da74849de0f8cba09d405dca4b6774/687474703a2f2f766572736f722e6d61742e756373622e6564752f7265736f75726365732f696d616765732f6c6f785f302e6a7067"><img src="https://camo.githubusercontent.com/58c09b4345f79c42a4e2a97ad3bd766492da74849de0f8cba09d405dca4b6774/687474703a2f2f766572736f722e6d61742e756373622e6564752f7265736f75726365732f696d616765732f6c6f785f302e6a7067" width="100" data-canonical-src="http://versor.mat.ucsb.edu/resources/images/lox_0.jpg" style="max-width: 100%;"></a></p>
<div class="markdown-heading" dir="auto"><h1 class="heading-element" dir="auto">Versor (libvsr)</h1><a id="user-content-versor-libvsr" class="anchor" aria-label="Permalink: Versor (libvsr)" href="#versor-libvsr"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">A (fast) Generic C++ library for Geometric Algebras, including Euclidean, Projective, Conformal, Spacetime (etc).</h2><a id="user-content-a-fast-generic-c-library-for-geometric-algebras-including-euclidean-projective-conformal-spacetime-etc" class="anchor" aria-label="Permalink: A (fast) Generic C++ library for Geometric Algebras, including Euclidean, Projective, Conformal, Spacetime (etc)." href="#a-fast-generic-c-library-for-geometric-algebras-including-euclidean-projective-conformal-spacetime-etc"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div class="markdown-heading" dir="auto"><h3 class="heading-element" dir="auto">Currently tested on Linux and Mac OS X</h3><a id="user-content-currently-tested-on-linux-and-mac-os-x" class="anchor" aria-label="Permalink: Currently tested on Linux and Mac OS X" href="#currently-tested-on-linux-and-mac-os-x"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="http://versor.mat.ucsb.edu" rel="nofollow">Homepage (versor.mat.ucsb.edu)</a></p>
<p dir="auto"><a href="http://wolftype.github.io/versor/devel/html/" rel="nofollow">Documentation</a></p>
<p dir="auto"><a href="http://versor.mat.ucsb.edu/masters_appendix.pdf" rel="nofollow">Combinatorics Cheat Sheet</a></p>
<p dir="auto"><a href="http://versor.mat.ucsb.edu/bibtex.txt" rel="nofollow">Bibtex (for referencing this work in your paper)</a></p>
<p dir="auto"><strong>Versor</strong> is a C++ Library for <strong>Geometric Algebra</strong>, sometimes called <strong>Clifford Algebra</strong>, a system for encoding geometric concepts numerically.</p>
<p dir="auto">The headers generate optimized code at compile-time through template metaprogramming.  The core of the library
is under 150kb, and supports arbitrary dimensions and metrics (limited by your compiler...).</p>
<p dir="auto">The library can be used as a math-only, or as an application with built-in graphics.  Both OpenGL and OpeGLES draw routines are supported.</p>
<p dir="auto">Lead Developer: Pablo Colapinto
<code>gmail: wolftype</code></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">CONTENTS:</h2><a id="user-content-contents" class="anchor" aria-label="Permalink: CONTENTS:" href="#contents"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li><a href="#recentchanges">Recent Changes</a></li>
<li><a href="#compilation">Compilation</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#generators">Generators</a></li>
<li><a href="#whatthepointis">What the Point is</a></li>
<li><a href="#basics">Basics</a></li>
<li><a href="#gui">Gui</a></li>
<li><a href="#operators">Operators</a></li>
<li><a href="#elements">Elements</a></li>
</ul>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Recent Changes</h2><a id="user-content-recent-changes" class="anchor" aria-label="Permalink: Recent Changes" href="#recent-changes"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Some major revisions have been enacted that change the API.</p>
<ul dir="auto">
<li>namespaces are used to distinguish between algebras:
<ul dir="auto">
<li><strong><code>vsr::nga::</code></strong> is the namespace for generic n-dimensional functions</li>
<li><strong><code>vsr::cga::</code></strong> is the namespace for 3D Conformal Geometric Algebra
<ul dir="auto">
<li>For example <strong><code>vsr::nga::Round::</code></strong> calls the generic implementation of n-D round elements whereas <strong><code>vsr::cga::Round::</code></strong> calls the 3D CGA specification</li>
</ul>
</li>
</ul>
</li>
<li>all static function structs (<strong><code>Round::</code></strong>, <strong><code>Flat::</code></strong>, <strong><code>Tangent::</code></strong>) are written in full (as opposed to <strong><code>Ro::</code></strong>, <strong><code>Fl::</code></strong> and <strong><code>Ta::</code></strong>).  We note these are Capitalized, since earlier versions of the devel branch used lowercase namespaces.</li>
<li><strong><code>Construct::</code></strong> is now used to construct useful objects within a particular namespace
<ul dir="auto">
<li>example: <strong><code>Construct::point(0,1,0)</code></strong> constructs a point at coordinate <code>(0,1,0)</code></li>
</ul>
</li>
<li>header folders <strong><code>/detail /space /form /draw</code></strong> and <strong><code>/util</code></strong> organize the various files</li>
</ul>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">LINKS:</h2><a id="user-content-links" class="anchor" aria-label="Permalink: LINKS:" href="#links"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><a href="http://lists.create.ucsb.edu/mailman/listinfo/versor" rel="nofollow">Mailing List</a> | <a href="http://www.allosphere.ucsb.edu/" rel="nofollow">AlloSphere Research Group</a></p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">PUBS:</h2><a id="user-content-pubs" class="anchor" aria-label="Permalink: PUBS:" href="#pubs"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">See also my page at <a href="https://ucsb.academia.edu/PabloColapinto" rel="nofollow">Academia.edu</a></p>
<p dir="auto">My disseration, <a href="http://versor.mat.ucsb.edu/ArticulatingSpace.pdf" rel="nofollow">Articulating Space</a>, introduces geometric algebra and explores applications to parametric design. My <a href="http://wolftype.com/versor/colapinto_masters_final_02.pdf" rel="nofollow">Master's Thesis</a> before it, serves as an introduction as well.</p>
<p dir="auto">At C++ Now in Aspen I gave <a href="https://www.youtube.com/watch?v=W4p-e-g37tg" rel="nofollow">a Presentation on Metaprogramming Implementation Details</a></p>
<blockquote>
<p dir="auto">As long as algebra and geometry have been separated, their progress have been slow and their uses limited; but when these two sciences have been united, they have lent each mutual forces, and have marched together towards perfection.</p>
<p dir="auto">-Joseph Louis Lagrange</p>
</blockquote>
<blockquote>
<p dir="auto">No attention should be paid to the fact that algebra and geometry are different in appearance.</p>
<p dir="auto">-Omar Khayyám</p>
</blockquote>
<blockquote>
<p dir="auto">L’algèbre n’est qu’une géométrie écrite; la géométrie n’est qu’une algèbre figurée.</p>
<p dir="auto">-Sophie Germain</p>
</blockquote>
<blockquote>
<p dir="auto">If you want to see, learn how to act</p>
<p dir="auto">-Heinz von Foerster</p>
</blockquote>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">OTHER NICE SOFTWARE:</h2><a id="user-content-other-nice-software" class="anchor" aria-label="Permalink: OTHER NICE SOFTWARE:" href="#other-nice-software"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li><a href="http://www.cinderella.de/tiki-index.php" rel="nofollow">Cinderella</a> Standalone GA interface</li>
<li><a href="http://www.science.uva.nl/ga/viewer/content_viewer.html" rel="nofollow">GAViewer</a> Standalone GA interface</li>
<li><a href="http://staff.science.uva.nl/~fontijne/g25.html" rel="nofollow">Gaigen</a> An Implementation Generator</li>
<li><a href="http://www.clucalc.info/" rel="nofollow">CluCalc/CluViz</a> Standalone and Library</li>
<li><a href="http://www.gaalop.de/" rel="nofollow">Gaalop</a> A precompiler to optimize CluScripts</li>
<li><a href="http://sourceforge.net/apps/trac/gaalet/" rel="nofollow">Gaalet</a> An expression template library whose backend is somewhat similar to Versor's</li>
<li><a href="http://www.github.com/weshoke/versor.js">versor.js</a> A javascript port of this library</li>
</ul>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">COMPILATION</h2><a id="user-content-compilation" class="anchor" aria-label="Permalink: COMPILATION" href="#compilation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">For this version you need C++11 support, which is now common (gcc 4.7 or higher or clang 3.2 or higher) and for graphics support you'll want glew.
See the <a href="#TROUBLESHOOTING">Troubleshooting</a> section below for instructions on installing glew.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="git clone https://github.com/wolftype/versor.git"><pre class="notranslate"><code>git clone https://github.com/wolftype/versor.git
</code></pre></div>
<p dir="auto">You'll need to initialize the submodules to build any graphics examples:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="cd versor
git submodule update --init --recursive"><pre class="notranslate"><code>cd versor
git submodule update --init --recursive
</code></pre></div>
<p dir="auto">To build library</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="./build.sh"><pre class="notranslate"><code>./build.sh
</code></pre></div>
<p dir="auto">To build library and examples:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="./build.sh --examples"><pre class="notranslate"><code>./build.sh --examples
</code></pre></div>
<p dir="auto">To build library without graphics:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="./build.sh --math"><pre class="notranslate"><code>./build.sh --math
</code></pre></div>
<p dir="auto">To compile and run programs in scratch/projects:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="./run.sh scratch/projects/&lt;folder&gt;/&lt;filename&gt;"><pre class="notranslate"><code>./run.sh scratch/projects/&lt;folder&gt;/&lt;filename&gt;
</code></pre></div>
<p dir="auto">Note that not all projects in the scratch folder will compile as I am in the process of updating them in this development branch.</p>
<p dir="auto">You can add your own file to the list of targets by adding it to /examples or scratch/projects//&lt;your_cpp_file&gt; and re-running <code>./build.sh</code>.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">INSTALLATION</h2><a id="user-content-installation" class="anchor" aria-label="Permalink: INSTALLATION" href="#installation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Hmmm, haven't added install options yet!  Will do so soon I promise.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Use Cases</h2><a id="user-content-use-cases" class="anchor" aria-label="Permalink: Use Cases" href="#use-cases"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ol dir="auto">
<li>A math library:</li>
</ol>
<hr>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="#include &lt;vsr/vsr.h&gt;

using Vec = vsr::euclidean_vector&lt;3,float&gt;;  		//&lt;-- A 3 dimensional euclidean vector defined over floats
using Biv = vsr::euclidean_bivector&lt;3,float&gt;;   //&lt;-- A 3 dimensional bivector or &quot;directed area element&quot;

int main(){

	auto v = Vec(1,2,3);		  			              //&lt;-- A 3D vector at coordinates 1,2,3;

	v.rotate( Biv::xy * .25 ).print();		        //&lt;-- Rotate the vector in the xy plane and print result

	return 0;
};"><pre class="notranslate"><code>#include &lt;vsr/vsr.h&gt;

using Vec = vsr::euclidean_vector&lt;3,float&gt;;  		//&lt;-- A 3 dimensional euclidean vector defined over floats
using Biv = vsr::euclidean_bivector&lt;3,float&gt;;   //&lt;-- A 3 dimensional bivector or "directed area element"

int main(){

	auto v = Vec(1,2,3);		  			              //&lt;-- A 3D vector at coordinates 1,2,3;

	v.rotate( Biv::xy * .25 ).print();		        //&lt;-- Rotate the vector in the xy plane and print result

	return 0;
};
</code></pre></div>
<ol start="2" dir="auto">
<li>A stand-alone application (with window and gui)</li>
</ol>
<hr>
<p dir="auto">(for now, please see examples/xEmptyProject.cpp for an example)</p>
<p dir="auto">While fully enabling arbitrary metric spaces, <em>Versor</em> has a lot of built-in functionality for specifically working with Conformal Geometric Algebra of 3D space, which is THE way to model all Euclidean transformations:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Point p = Round::point(0,0,0);

auto tp = p.translate(x, y, z);

auto rp = p.rotate( Biv::xy * theta)"><pre class="notranslate"><code>Point p = Round::point(0,0,0);

auto tp = p.translate(x, y, z);

auto rp = p.rotate( Biv::xy * theta)
</code></pre></div>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">TROUBLESHOOTING</h2><a id="user-content-troubleshooting" class="anchor" aria-label="Permalink: TROUBLESHOOTING" href="#troubleshooting"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li>
<p dir="auto">You may need to install Glew on newer macs.  Best way to do this is with brew:</p>
<p dir="auto">brew install glew</p>
</li>
<li>
<p dir="auto">You'll need C++11 support on your compiler (See makefile notes below). For C++11 you'll want clang 3.2 (mac) or above or gcc 4.7 or above (linux).</p>
</li>
<li>
<p dir="auto">On Linux: you may need to sudo apt-get install libxmu-dev libxi-dev</p>
</li>
<li>
<p dir="auto">Alternatively an earlier version of Versor is available at <a href="https://github.com/wolftype/versor_1.0.git">github.com/wolftype/versor_1.0.git</a>
This older version runs just as fast, but is strictly 3D CGA (i.e. R4,1 metric) since I generated headers ahead of time.</p>
</li>
</ul>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">INTRODUCTION</h2><a id="user-content-introduction" class="anchor" aria-label="Permalink: INTRODUCTION" href="#introduction"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><em>Versor</em> provides operations and draw routines for Euclidean and Conformal Geometric Algebras,
a relatively new spatial computing model used by physicists, engineers, and artists. <em>Versor</em> is designed to make graphical
experimentation of geometric algebra within a C++ environment easier. You can use this library to draw geometrical things, explore
spherical and hyperbolic spaces, transformations, design robots, etc.
I am using it for my PhD on bio-inspired engineering.</p>
<p dir="auto">I first developed <em>Versor</em> while reading "Geometric Algebra for Computer Science" by Leo Dorst, Daniel Fontijne, and Stephen Mann.
It's a fantastic book and if you're reading this you should also consider reading that.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">License</h2><a id="user-content-license" class="anchor" aria-label="Permalink: License" href="#license"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This software is licensed under the  FreeBSD (2-clause) open source license (see copyrights/COPYRIGHT).  This is a permissive and compatible open source license -- you are pretty much free to do what you want with the source code.  In addition, you are strongly encouraged to email me to let me know how it is being used, so that we can all learn more.</p>
<p dir="auto">Built to aid in my modelling of organic forms, the initial development was partially funded by the Olivia Long Converse Fellowship for Botanic research, courtesy of the Graduate Division at the University of California in Santa Barbara.  It has also received support from the Robert W. Deutsch Foundation.</p>
<hr>
<p dir="auto">One quick word: clifford algebras and the spatial relationships they embody can often feel abstract and daunting.  But it's a twisty, boosty ride, full of weird discoveries.  You're bound to make some, so have fun!</p>
<hr>
<div class="markdown-heading" dir="auto"><h4 class="heading-element" dir="auto">BACKGROUND</h4><a id="user-content-background" class="anchor" aria-label="Permalink: BACKGROUND" href="#background"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The homogenous 5D CGA model used here was initially proposed by David Hestenes, Hongbo Li, and Alan Rockwood in 2001, and given full form and weight through the excellent
and careful work of Leo Dorst, Joan and Anthony Lasenby, and Eduardo Bayro-Corrochano, and others.  These researchers' writings have helped me quite a bit.  CGA is particular breed of <em>Clifford Algebras</em> (also known as Geometric Algebras),
which operate upon combinatoric hypercomplex vector spaces that emerged from William Clifford's attempt to fuse Hamilton's quaternions with Grassmans' extension algebras.  Thus
<em>transformations</em> were married with a system of <em>abstraction</em>.  For more information, take a look at the <a href="#links">links</a> to the sites at the bottom of
this page.  For instance, for practical applications in robotics and "Geometric Cybernetics", see Eduardo Bayro-Corrochano's work.  For some
very helpful algorithms in rigid body dynamics and gravitational physics see the variety of publications by Joan and Anthony Lasenby.  To get at the beginning of it all, read David Hestenes' <em>New Foundations for Classical Mechanics</em>.</p>
<div class="markdown-heading" dir="auto"><h4 class="heading-element" dir="auto">SPEED</h4><a id="user-content-speed" class="anchor" aria-label="Permalink: SPEED" href="#speed"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Typical matrix operation libraries have templated inlined functions for Vector and Matrix multiplication.  Versor
is similar, but on steroids, where <em>vectors</em> and sparse <em>matrices</em> of various sizes are all just called <em>multivectors</em> and represent geometric
elements beyond just xyz directions and transformation matrices. Circles, lines, spheres, planes, points are all algebraic elements, as are
operators that spin, twist, dilate, and bend those variables.  Both these elements and operators are <em>multivectors</em> which multiply together in many many many different ways.</p>
<div class="markdown-heading" dir="auto"><h4 class="heading-element" dir="auto">What's new?</h4><a id="user-content-whats-new" class="anchor" aria-label="Permalink: What's new?" href="#whats-new"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Versor compiles much faster than before, and without any silly predetermined list
of allowable operations or types.  Most notably, arbitrary metrics are now possible.  For example,
the xRoots.cpp example calculates all the Euclidean 4D reflections of a couple of point groups
(F4 and D4, namely). So you can hypercube and polychoron away (8D cubes no problem!).  Number of dimensions
allowed are somewhat limited by your compiler infrastructure -- let me know if you have a need that is not being met!</p>
<p dir="auto">As for CGA, all the Pnt, Vec, Dll notation remains as before, but i've started adding utility functions
since it helps people out.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="auto pa = Round::point( 1,0,0 );
auto pb = Round::point( 0,1,0 );
auto pc = Round::point(-1,0,0 );
auto circle = pa ^ pb ^ pc;

Draw(c);"><pre class="notranslate"><code>auto pa = Round::point( 1,0,0 );
auto pb = Round::point( 0,1,0 );
auto pc = Round::point(-1,0,0 );
auto circle = pa ^ pb ^ pc;

Draw(c);
</code></pre></div>
<div class="markdown-heading" dir="auto"><h4 class="heading-element" dir="auto">How does it work?</h4><a id="user-content-how-does-it-work" class="anchor" aria-label="Permalink: How does it work?" href="#how-does-it-work"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">If you like functional template metaprogramming, take a look at the code
and please let me know what you think.  If you don't, then I wouldn't . . .
But if you have ideas or questions please do not hesitate to contact me.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">WHAT THE POINT IS</h2><a id="user-content-what-the-point-is" class="anchor" aria-label="Permalink: WHAT THE POINT IS" href="#what-the-point-is"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">GA combines many other maths (matrix, tensor, vector, and lie algebras). It is <strong>holistic</strong>. CGA uses a particular mapping (a conformal one) of 3D Euclidean space to a
4D sphere. Operations on that hypersphere are then projected back down to 3D. That how it works in a nutshell.</p>
<p dir="auto">A fuller treatment of this question (er, the question of why we do this) can be found in my <a href="http://wolftype.com/versor/colapinto_masters_final_02.pdf" rel="nofollow">Master's thesis on the subject</a>.  But basically,
Geometic Algebra offers a particular richness of spatial expression.  Imagine needing glasses and not knowing you needed glasses.  Then, when you do get glasses, the world changes
unexpectedly.  GA is like glasses for the inside of your brain.  <em>Conformal</em> Geometric Algebra, especially the 5D variety enlisted here, are like x-ray glasses.  One
point of clarification that occurs are <strong>disambiguations</strong> of previously collapsed concepts.</p>
<p dir="auto">For instance, the main disambiguation, is that between a <em>Point</em> in space and a <em>Vector</em> in space.
A Point has no magnitude, but a Vector does.  A Point has no direction, but a Vector does. Points are <em>null</em> Vectors.  We can make them
by writing</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Vec( 1,0,0 ).null();"><pre class="notranslate"><code>Vec( 1,0,0 ).null();
</code></pre></div>
<ul dir="auto">
<li>Points are null Vectors</li>
<li>Points square to 0</li>
<li>The dot (inner) product of two Points returns their squared distance</li>
<li>The wedge (outer) product of two Points returns a Point Pair</li>
</ul>
<p dir="auto">More on that last point later . . . there are various binary operators defined (mainly three).  We can introduce one right now, which is the <strong>dot</strong> or <strong>inner</strong> product.
In mathematics, the inner product of two points <code>pa</code> and <code>pb</code> is written \(p_{a} \rfloor p_{b}\).  In <em>Versor</em> we use the <code>&lt;=</code> operator:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Point pa = Vec(1,0,0).null();
Point pb = Vec(-1,0,0).null();
Scalar squaredDist = ( pa &lt;= pb ) * -2;"><pre class="notranslate"><code>Point pa = Vec(1,0,0).null();
Point pb = Vec(-1,0,0).null();
Scalar squaredDist = ( pa &lt;= pb ) * -2;
</code></pre></div>
<p dir="auto">which in this case would return a Scalar value of <code>4</code>.  The <code>-2</code> is there since the inner product really returns <strong>half the negative</strong> squared distance.
We can extract the Scalar into a c++ double like so:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="double squaredDist = ( pa &lt;= pb )[0] * -2;"><pre class="notranslate"><code>double squaredDist = ( pa &lt;= pb )[0] * -2;
</code></pre></div>
<p dir="auto">Points thought of as Spheres (really, Dual Spheres, more on <em>Duality</em> later): they are Spheres of zero radius.  As such they are a type of <em>Round</em> element.  We can also build points this way:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Round::null( 1,0,0 );"><pre class="notranslate"><code>Round::null( 1,0,0 );
</code></pre></div>
<p dir="auto">or you can pass in another element</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Round::null( Vec(1,0,0) );"><pre class="notranslate"><code>Round::null( Vec(1,0,0) );
</code></pre></div>
<p dir="auto">or use the built-in method</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Point pa = Vec(1,0,0).null();"><pre class="notranslate"><code>Point pa = Vec(1,0,0).null();
</code></pre></div>
<p dir="auto">Points can also be made with the macro <code>PT</code></p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Point pa = PT(1,0,0);"><pre class="notranslate"><code>Point pa = PT(1,0,0);
</code></pre></div>
<p dir="auto">which is just "syntactic sugar" for <code>Vec(1,0,0).null()</code></p>
<p dir="auto">Speaking of Spheres, we can also make spheres with a radius this way:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="DualSphere dls = Round::dls( Vec( 1,0,0 ).null(), 1 );"><pre class="notranslate"><code>DualSphere dls = Round::dls( Vec( 1,0,0 ).null(), 1 );
</code></pre></div>
<p dir="auto">or</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="DualSphere dls = Round::dls( Vec( 1,0,0 ), 1 );"><pre class="notranslate"><code>DualSphere dls = Round::dls( Vec( 1,0,0 ), 1 );
</code></pre></div>
<p dir="auto">or, specifying the radius first and then the coordinate:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="DualSphere dls = Round::dls( 1 /* &lt;--radius */ , 1,0,0 )"><pre class="notranslate"><code>DualSphere dls = Round::dls( 1 /* &lt;--radius */ , 1,0,0 )
</code></pre></div>
<p dir="auto">all of which give a dual sphere of radius 1 at coordinate 1,0,0;</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">BASICS</h2><a id="user-content-basics" class="anchor" aria-label="Permalink: BASICS" href="#basics"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><em>Versor</em> is named after the one of the basic category of elements of geometric algebra.
A <strong>versor</strong> is a type of <strong>multivector</strong> which can be used to compose geometric transformations,
namely reflections, translations, rotations, twists, dilations, and transversions (special conformal transformations).</p>
<p dir="auto">More on all of those transformations later.</p>
<p dir="auto">In Versor, a <code>Vector</code> (or <code>Vec</code>) is a typical Euclidean 3D element.  It can be built in the normal way:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Vec v(1,2,3);"><pre class="notranslate"><code>Vec v(1,2,3);
</code></pre></div>
<p dir="auto">Some built-in Vectors exist:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Vec::x x; //&lt;-- X Direction Unit Vector Vec(1,0,0)
Vec::y y; //&lt;-- Y Direction Unit Vector Vec(0,1,0)
Vec::z z; //&lt;-- Z Direction Unit Vector Vec(0,0,1)"><pre class="notranslate"><code>Vec::x x; //&lt;-- X Direction Unit Vector Vec(1,0,0)
Vec::y y; //&lt;-- Y Direction Unit Vector Vec(0,1,0)
Vec::z z; //&lt;-- Z Direction Unit Vector Vec(0,0,1)
</code></pre></div>
<p dir="auto">A <code>Vector</code> can be spun around using a <code>Rotor</code>, which is exactly like a quaternion.  However, whereas quaternions are often built by specifying an axis
and an angle, rotors are built by specifying the <strong>plane</strong> of rotation.  Eventually this will make much more sense to you: in general <strong>planes</strong> are what we
will be using to transform things.  For instance, a reflection is a reflection in a plane.  As we will see, planes can become <strong>hyperplanes</strong> which will allow for more extraordinary transformations.</p>
<p dir="auto">The first completely new element to introduce is the <code>Bivector</code>, which is the plane we will use to generate our <code>Rotor</code>.  Bivectors represent <strong>directed areas</strong> and are <strong>dual</strong>
to the cross product: the cross product of two vectors in typical vector algebra returns a vector normal to the plane they define.  So it is not completely new,
but just sort of new.</p>
<p dir="auto">Bivectors are also just three elements long, and are built the same way Vectors are.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Biv b(1,2,3);"><pre class="notranslate"><code>Biv b(1,2,3);
</code></pre></div>
<p dir="auto">Some built-in Bivectors exist:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Biv::xy xy; //&lt;-- XY Counterclockwise Unit Area Biv(1,0,0)
Biv::xz xz; //&lt;-- XZ Counterclockwise Unit Area Biv(0,1,0)
Biv::yz yz; //&lt;-- YZ Counterclockwise Unit Area Biv(0,0,1)"><pre class="notranslate"><code>Biv::xy xy; //&lt;-- XY Counterclockwise Unit Area Biv(1,0,0)
Biv::xz xz; //&lt;-- XZ Counterclockwise Unit Area Biv(0,1,0)
Biv::yz yz; //&lt;-- YZ Counterclockwise Unit Area Biv(0,0,1)
</code></pre></div>
<p dir="auto">While it is perfectly valid to write <code>Vector</code>, <code>Bivector</code> and <code>Rotor</code>, you'll notice I've truncated them to their three letter nicknames, <code>Vec</code> and <code>Rot</code>.
That's up to you: Both long-name and nick-name versions are valid in libvsr (they are typedef'ed to each other).</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Biv b = Biv::xy;
double theta = PIOVERTWO;
Vec v1 = Vec::x.rot( b * theta )"><pre class="notranslate"><code>Biv b = Biv::xy;
double theta = PIOVERTWO;
Vec v1 = Vec::x.rot( b * theta )
</code></pre></div>
<p dir="auto">You can also generate rotors using <code>Gen::rot( &lt;some bivector&gt; )</code>  In fact, all transformations can be generated this way, and then later applied to arbitrary elements.
For instance, <code>Motors</code> can be generated which translate and rotate an element at the same time.  This is also called a <em>twist</em>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Motor m = Gen::mot(&lt;some dual line&gt;); 	//&lt;-- Makes A Twisting Motor around Some Dual Line
Point p = Vec(0,0,0).null().sp(m);		//&lt;-- Applies above motor to a Point"><pre class="notranslate"><code>Motor m = Gen::mot(&lt;some dual line&gt;); 	//&lt;-- Makes A Twisting Motor around Some Dual Line
Point p = Vec(0,0,0).null().sp(m);		//&lt;-- Applies above motor to a Point
</code></pre></div>
<p dir="auto">You'll notice there are <em>dual</em> versions of elements: as in a <code>DualLine</code> (or <code>Dll</code> for short).  That's because in the real world of abstract geometry, there are usually
two ways of defining an element.  For instance, we can build a <em>direct</em> <code>Line</code> on the Y-axis by wedging two points together, along with infinity:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Line lin = Vec(0,0,0).null() ^ Vec(0,1,0).null() ^ Inf(1);"><pre class="notranslate"><code>Line lin = Vec(0,0,0).null() ^ Vec(0,1,0).null() ^ Inf(1);
</code></pre></div>
<p dir="auto">Or we can define a line by the bivector plane that it is normal to, and a support vector that determines how far away the line is from the origin.  To convert the above
line into its dual representation, we just call the dual() method:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Dll dll = lin.dual();"><pre class="notranslate"><code>Dll dll = lin.dual();
</code></pre></div>
<p dir="auto">For those who are interested, this dual representation is isomorphic to the Plücker coordinates, which are used in screw theory to twist things around.  Here, too, we can use
dual lines to generate transformations which twist things around them.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">Gui</h2><a id="user-content-gui" class="anchor" aria-label="Permalink: Gui" href="#gui"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The examples/*.cpp files include bindings to the GLV framework for windowing and user interface controls. This provides the minumum necessary glue to get started quickly building your own GA based graphics applications.</p>
<p dir="auto">The interface has a built in gui, mouse info, and keyboard info stored.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="//... a member of your App
Circle circle;
//...in App::setup()
objectController.attach(&amp;circle);"><pre class="notranslate"><code>//... a member of your App
Circle circle;
//...in App::setup()
objectController.attach(&amp;circle);
</code></pre></div>
<p dir="auto">Putting the above code inside your application will enable you to click and modify geometric elements by hitting the "T", "R" and "S" keys (for translate, rotate, and scale)
Hit any other key to deselect all elements.</p>
<p dir="auto">[<strong>BUILT-IN INTERFACE</strong>]</p>
<p dir="auto">|                                 |                                             |</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Response</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>~</code></td>
<td>Toggle full screen.</td>
</tr>
<tr>
<td><code>SHIFT</code> + <code>Mouse</code> or <code>Arrow Keys</code></td>
<td>Translate the camera  in x and z directions.</td>
</tr>
<tr>
<td><code>CTRL</code>+ <code>Mouse</code> or <code>Arrow Keys</code></td>
<td>Rotate the camera</td>
</tr>
<tr>
<td><code>ALT</code> +<code>Arrow Keys</code></td>
<td>Rotate the model view around.</td>
</tr>
<tr>
<td><code>T</code></td>
<td>Translate an Element</td>
</tr>
<tr>
<td><code>R</code></td>
<td>Rotate an Element</td>
</tr>
<tr>
<td><code>S</code></td>
<td>Scale an Element</td>
</tr>
<tr>
<td><code>Tab</code></td>
<td>Switch from navigation mode (default) to object manipulation mode</td>
</tr>
<tr>
<td>Any other key</td>
<td>Release all Elements</td>
</tr>
</tbody>
</table>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">OPERATORS</h2><a id="user-content-operators" class="anchor" aria-label="Permalink: OPERATORS" href="#operators"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The elements of the algebra are geometric entities (circles, planes, spheres, etc) and operators (rotations, translations, twists, etc) which
act on the elements of the algebra.  All are known as <em>multivectors</em> since they are more than just your typical vectors.</p>
<p dir="auto">Multivector elements are most often combined using three overloaded binary operators:</p>
<p dir="auto">The <strong>Geometric</strong> Product of elements <code>A</code> and <code>B</code>:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="A * B"><pre class="notranslate"><code>A * B
</code></pre></div>
<p dir="auto">multiplies two multivector elements together.  This is most useful when multiplying one by the inverse of another (see <code>!</code> operator, below).</p>
<p dir="auto">The <strong>Outer</strong> Product of elements <code>A</code> and <code>B</code>:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="A ^ B"><pre class="notranslate"><code>A ^ B
</code></pre></div>
<p dir="auto">"wedges" two multivectors together.  Its from Grassman's algebra of extensions, and can be thought of as a way of creating higher dimensions from smaller ones.
For instance, wedging two <code>Vectors</code> (directed magnitudes) together returns a <code>Bivector</code> (a directed Area).  Wedging two <code>Points</code> together returns a <code>PointPair</code>.
Wedging three <code>Points</code> together returns a <code>Circle</code>.</p>
<p dir="auto">The <strong>Inner</strong> Product of elements <code>A</code> and <code>B</code>:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="A&lt;=B"><pre class="notranslate"><code>A&lt;=B
</code></pre></div>
<p dir="auto">There is also a <strong>Commutator</strong> product (differential)</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="A%B"><pre class="notranslate"><code>A%B
</code></pre></div>
<p dir="auto">And a few overloaded operations, including,</p>
<p dir="auto">The Inverse:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="!A"><pre class="notranslate"><code>!A
</code></pre></div>
<p dir="auto">returns \(A^{-1}\)</p>
<p dir="auto">The Reverse:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="~A"><pre class="notranslate"><code>~A
</code></pre></div>
<p dir="auto">returns \(\tilde{A}\)</p>
<p dir="auto">And finally, since I ran out of overloadable operators, some basic methods</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="A.conj()"><pre class="notranslate"><code>A.conj()
</code></pre></div>
<p dir="auto">which returns \(\bar{A}\)</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="A.inv()"><pre class="notranslate"><code>A.inv()
</code></pre></div>
<p dir="auto">which returns \(\hat{A}\)</p>
<p dir="auto">In summary:</p>
<p dir="auto">| Versor     | Math                                              |                                          Description                                         |   |   |
| ---------- | ------------------------------------------------- | :------------------------------------------------------------------------------------------: | - |
| <code>A * B</code>    | \(AB\)                                          | Multiplies two elements together (and, in the case of A * !B finds ratios between elements). |
| <code>A ^ B</code>    | \(A \wedge B\)                                  |             Wedges two elements together (builds up higher dimensional elements).            |
| <code>A &lt;= B</code>   | \(A \rfloor B\) or \(\boldsymbol{a} \cdot B\) |             Contracts A out of B (returns the part of B "least like A", sort of).            |
| <code>A % B</code>    | \(A \times B\)                                  |                         Commutator, equal to \(\frac{1}{2}(AB-BA)\)                        |
| <code>!A</code>       | \(A^{-1}\)                                      |                                       The Inverse of A.                                      |
| <code>~A</code>       | \(\tilde{A}\)                                   |                                       The Reverse of A.                                      |
| <code>A.conj()</code> | \(\bar{A}\)                                     |                                         Conjugation.                                         |
| <code>A.inv()</code>  | \(\hat{A}\)                                     |                                          Involution.                                         |</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">ELEMENTS</h2><a id="user-content-elements" class="anchor" aria-label="Permalink: ELEMENTS" href="#elements"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">To make the process of writing code faster, all elements of the algebra are represented by types 3 letters long.
Alternatively, you can also use the long-form name.</p>
<p dir="auto">[<strong>BASIC ELEMENTS</strong>]</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Long Form</th>
<th align="center">Descrription</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>Euclidean</em></td>
<td></td>
<td align="center"></td>
</tr>
<tr>
<td><code>Sca</code></td>
<td><code>Scalar</code></td>
<td align="center">A real number</td>
</tr>
<tr>
<td><code>Vec</code></td>
<td><code>Vector</code></td>
<td align="center">A Directed Magnitude, or 3D Vector, typical cartesian stuff</td>
</tr>
<tr>
<td><code>Biv</code></td>
<td><code>Bivector</code></td>
<td align="center">A Directed Area. Use them to make Rotors: <code>Gen::Rot( Biv b )</code></td>
</tr>
<tr>
<td><code>Tri</code></td>
<td><code>Trivector</code></td>
<td align="center">A Directed Volume Element</td>
</tr>
</tbody>
</table>
<p dir="auto"><em>Round</em>                 ||
<code>Pnt</code> | <code>Point</code>          |           A Null Vector: <code>Pnt a = Vec(1,0,0).null()</code>
<code>Par</code> | <code>PointPair</code>      |    A 0-Sphere (Sphere on a Line): <code>Par par = Pnt a ^ Pnt b</code>
<code>Cir</code> | <code>Circle</code>         |         A 1-Sphere: <code>Cir cir = Pnt a ^ Pnt b ^ Pnt c</code>
<code>Sph</code> | <code>Sphere</code>         |     A 2-Sphere: <code>Sph sph = Pnt a ^ Pnt b ^ Pnt c ^ Pnt d</code>
<code>Dls</code> | <code>DualSphere</code>     |            Typedef'ed as a point: <code>typedef Pnt Dls</code></p>
<p dir="auto"><em>Flat</em>                  ||
<code>Lin</code> | <code>Line</code>           |        A Direct Line: e.g. <code>Lin lin = Par par ^ Inf(1)</code>
<code>Dll</code> | <code>DualLine</code>       |            A Dual Line: e.g. <code>Dll dll = lin.dual()</code>
<code>Pln</code> | <code>Plane</code>          |       A Direct Plane: e.g. <code>Pln pln = Cir cir ^ Inf(1)</code>
<code>Dlp</code> | <code>DualPlane</code>      |                A Dual Plane: e.g. <code>Dlp dlp = </code>
<code>Flp</code> | <code>FlatPoint</code>      |</p>
<p dir="auto"><em>Versors</em>               ||
<code>Rot</code> | <code>Rotor</code>          |            Spins an Element (as a Quaternion would)
<code>Trs</code> | <code>Translator</code>     |                     Translates an Element
<code>Dil</code> | <code>Dilator</code>        |                       Dilates an Element
<code>Mot</code> | <code>Motor</code>          |                Twists an Element along an axis
<code>Trv</code> | <code>Transversor</code>    |                        Bends an Element about the Origin
<code>Bst</code> | <code>Booster</code>        |                        Bends an Element around an "Orbit"</p>
<p dir="auto"><em>Abstract</em>              ||
<code>Mnk</code> | <code>MinkowskiPlane</code> |
<code>Pss</code> | <code>Pseudoscalar</code>   |
<code>Inf</code> | <code>Infinity</code>       |</p>
<p dir="auto">There are others as well (for instance, affine planes, lines, and points) but the above are more than sufficient to start with.
There are also built in macros, for instance</p>
<p dir="auto"><code>EP</code>  			| Sphere At the Origin.
<code>EM</code>  			| Imaginary Sphere at the Origin.
<code>PT(x,y,z)</code>  	| A null Point at x,y,z</p>
<p dir="auto"><code>EP</code> and <code>EM</code> can be invoked instead of <code>Inf</code> to work in non-Euclidean metrics ( Spherical and Hyperbolic, respectively)</p>
<p dir="auto">Many Euclidean elements can be drawn by invoking Draw::Render().  Some can't (yet) either because it wasn't obvious
how to draw them (e.g the scalar) or because I just didn't figure out how to do it or because I forgot or was lazy.  If you
want something to be drawable, let me know and I'll add it in.  Or try adding it in yourself and send a pull request via github.</p>
<p dir="auto">All elements can be dualized by invoking their <code>dual()</code> method</p>
<p dir="auto">All elements can be reflected over spinors with the <code>sp(&lt;spinor&gt;)</code> method</p>
<p dir="auto">All elements can be reflected over versors with the <code>re(&lt;versor&gt;)</code> method</p>
<p dir="auto">The versors are constructed by the geometric entities, typically by using the <code>Gen::</code> routines.  Operators can also be acted on by operators -- you can rotate a translation, or twist a boost.</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">COMMON CONFORMAL FUNCTIONS</h2><a id="user-content-common-conformal-functions" class="anchor" aria-label="Permalink: COMMON CONFORMAL FUNCTIONS" href="#common-conformal-functions"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto"><code>vsr_generic_op.h</code> and <code>vsr_cga3D_op.h</code> contain the bulk of the functions for generating elements from other elements.  Some guidelines:</p>
<ul dir="auto">
<li><code>Gen::</code> methods <strong>generate</strong> or otherwise operate on versors</li>
<li><code>roond::</code> methods create or otherwise operate on <strong>Round</strong> elements (Points, Point Pairs, Circles, Spheres)</li>
<li><code>Flat::</code> methods create or otherwise operate on <strong>Flat</strong> elements (Lines, Dual Lines, Planes, Dual Planes, or Flat Points)</li>
<li><code>Tangent::</code> methods create or otherwise operate on <strong>Tangent</strong> elements (Tangent Vectors, Tangent Bivectors, Tangent Trivectors)</li>
</ul>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">GENERATORS</h2><a id="user-content-generators" class="anchor" aria-label="Permalink: GENERATORS" href="#generators"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">|       |                                     |</p>
<table>
<thead>
<tr>
<th>Returns</th>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Rot</td>
<td>Gen::rot( const Biv&amp; b );</td>
<td>//&lt;-- Generate a Rotor from a Bivector</td>
</tr>
<tr>
<td>Trs</td>
<td>Gen::trs( const Drv&amp; v);</td>
<td>//&lt;-- Generate a Translator from a Direction Vector</td>
</tr>
<tr>
<td>Mot</td>
<td>Gen::mot( const Dll&amp; d);</td>
<td>//&lt;-- Generate a Motor from a Dual Line</td>
</tr>
<tr>
<td>Dil</td>
<td>Gen::dil( const Pnt&amp; p, double amt );</td>
<td>//&lt;-- Generate a Dilator from a Point and an amount</td>
</tr>
<tr>
<td>Trv</td>
<td>Gen::trv( cont Tnv&amp; v);</td>
<td>//&lt;-- Generate a Transveror from a Tangent Vector</td>
</tr>
<tr>
<td>Bst</td>
<td>Gen::bst( const Par&amp; p);</td>
<td>//&lt;-- Generate a Booster from a Point Pair</td>
</tr>
</tbody>
</table>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">REFLECTIONS</h2><a id="user-content-reflections" class="anchor" aria-label="Permalink: REFLECTIONS" href="#reflections"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">In addition to the above "even" spinors, we can also reflect.  Reflections (in a sphere, circle, or point pair, or over a line or plane ) can be calculated by writing</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="Pnt p = PT(1,0,0);
Pnt r = p.re( CXY(1) ); //Reflection of a point in a circle
r = r / r[3]; 			    //Renormalization of a point"><pre class="notranslate"><code>Pnt p = PT(1,0,0);
Pnt r = p.re( CXY(1) ); //Reflection of a point in a circle
r = r / r[3]; 			    //Renormalization of a point
</code></pre></div>
<p dir="auto">The re() method calculates <code>v.re(C)</code> as <code>C*v.inv()*~C</code> where inv() is an involution. With a versor <code>C</code> and an element <code>v</code> you might also try <code>C * v * !C</code>.  Inversion in a circle or a sphere may change the
weight of the element (for a Point at x, it will change it by x^2)</p>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">LINKS</h2><a id="user-content-links-1" class="anchor" aria-label="Permalink: LINKS" href="#links-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li><a href="http://vimeo.com/wolftype" rel="nofollow">Some Video Demos of Versor</a></li>
<li><a href="http://www.geometricalgebra.net/" rel="nofollow">The Good Book: <em>Geometric Algebra for Computer Science</em></a></li>
<li><a href="http://www.delicious.com/tag/geometricalgebra" rel="nofollow">GA Bookmarks on Delicious</a></li>
<li><a href="https://groups.google.com/forum/?fromgroups#!forum/geometric_algebra" rel="nofollow">GA Google Group</a></li>
<li><a href="http://geocalc.clas.asu.edu/" rel="nofollow">David Hestenes' Geometric Calculus Page</a></li>
<li><a href="http://www.science.uva.nl/research/isla/" rel="nofollow">University of Amsterdam Intelligent Systems Lab</a></li>
<li><a href="http://www.gdl.cinvestav.mx/~edb/" rel="nofollow">Eduardo Bayro-Corrochano's Robotics Lab</a></li>
<li><a href="http://www.mrao.cam.ac.uk/~clifford/" rel="nofollow">Cambridge University Geometric Algebra Research Group</a></li>
<li><a href="http://www.mrao.cam.ac.uk/~clifford/" rel="nofollow">Cognitive Systems at Christian-Albrechts-Universität zu Kiel</a></li>
</ul>
<div class="markdown-heading" dir="auto"><h2 class="heading-element" dir="auto">PAPERS</h2><a id="user-content-papers" class="anchor" aria-label="Permalink: PAPERS" href="#papers"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ul dir="auto">
<li>2011 <a href="http://wolftype.com/versor/colapinto_masters_final_02.pdf" rel="nofollow">Versor: Spatial Computing With Conformal Geometric Algebra</a></li>
<li>2012 <a href="http://versor.mat.ucsb.edu/Boosted_Surfaces_submission_0113.pdf" rel="nofollow">Boosted Surfaces: Synthesis of Meshes using Point Pair Generators in the Conformal Model</a></li>
</ul>
</article></div>